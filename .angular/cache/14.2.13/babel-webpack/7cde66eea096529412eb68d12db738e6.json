{"ast":null,"code":"/*! @azure/msal-common v13.3.1 2023-10-27 */\n'use strict';\n\nimport { __assign } from '../../_virtual/_tslib.js';\nimport { IntFields, PerformanceEventStatus } from './PerformanceEvent.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nvar PerformanceClient =\n/** @class */\nfunction () {\n  /**\r\n   * Creates an instance of PerformanceClient,\r\n   * an abstract class containing core performance telemetry logic.\r\n   *\r\n   * @constructor\r\n   * @param {string} clientId Client ID of the application\r\n   * @param {string} authority Authority used by the application\r\n   * @param {Logger} logger Logger used by the application\r\n   * @param {string} libraryName Name of the library\r\n   * @param {string} libraryVersion Version of the library\r\n   */\n  function PerformanceClient(clientId, authority, logger, libraryName, libraryVersion, applicationTelemetry) {\n    this.authority = authority;\n    this.libraryName = libraryName;\n    this.libraryVersion = libraryVersion;\n    this.applicationTelemetry = applicationTelemetry;\n    this.clientId = clientId;\n    this.logger = logger;\n    this.callbacks = new Map();\n    this.eventsByCorrelationId = new Map();\n    this.queueMeasurements = new Map();\n    this.preQueueTimeByCorrelationId = new Map();\n  }\n  /**\r\n   * Starts and returns an platform-specific implementation of IPerformanceMeasurement.\r\n   * Note: this function can be changed to abstract at the next major version bump.\r\n   *\r\n   * @param {string} measureName\r\n   * @param {string} correlationId\r\n   * @returns {IPerformanceMeasurement}\r\n   */\n\n  /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n\n\n  PerformanceClient.prototype.startPerformanceMeasurement = function (measureName, correlationId) {\n    return {};\n  };\n  /**\r\n   * Starts and returns an platform-specific implementation of IPerformanceMeasurement.\r\n   * Note: this incorrectly-named function will be removed at the next major version bump.\r\n   *\r\n   * @param {string} measureName\r\n   * @param {string} correlationId\r\n   * @returns {IPerformanceMeasurement}\r\n   */\n\n  /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n\n\n  PerformanceClient.prototype.startPerformanceMeasuremeant = function (measureName, correlationId) {\n    return {};\n  };\n  /**\r\n   * Get integral fields.\r\n   * Override to change the set.\r\n   */\n\n\n  PerformanceClient.prototype.getIntFields = function () {\n    return IntFields;\n  };\n  /**\r\n   * Gets map of pre-queue times by correlation Id\r\n   *\r\n   * @param {PerformanceEvents} eventName\r\n   * @param {string} correlationId\r\n   * @returns {number}\r\n   */\n\n\n  PerformanceClient.prototype.getPreQueueTime = function (eventName, correlationId) {\n    var preQueueEvent = this.preQueueTimeByCorrelationId.get(correlationId);\n\n    if (!preQueueEvent) {\n      this.logger.trace(\"PerformanceClient.getPreQueueTime: no pre-queue times found for correlationId: \" + correlationId + \", unable to add queue measurement\");\n      return;\n    } else if (preQueueEvent.name !== eventName) {\n      this.logger.trace(\"PerformanceClient.getPreQueueTime: no pre-queue time found for \" + eventName + \", unable to add queue measurement\");\n      return;\n    }\n\n    return preQueueEvent.time;\n  };\n  /**\r\n   * Calculates the difference between current time and time when function was queued.\r\n   * Note: It is possible to have 0 as the queue time if the current time and the queued time was the same.\r\n   *\r\n   * @param {number} preQueueTime\r\n   * @param {number} currentTime\r\n   * @returns {number}\r\n   */\n\n\n  PerformanceClient.prototype.calculateQueuedTime = function (preQueueTime, currentTime) {\n    if (preQueueTime < 1) {\n      this.logger.trace(\"PerformanceClient: preQueueTime should be a positive integer and not \" + preQueueTime);\n      return 0;\n    }\n\n    if (currentTime < 1) {\n      this.logger.trace(\"PerformanceClient: currentTime should be a positive integer and not \" + currentTime);\n      return 0;\n    }\n\n    if (currentTime < preQueueTime) {\n      this.logger.trace(\"PerformanceClient: currentTime is less than preQueueTime, check how time is being retrieved\");\n      return 0;\n    }\n\n    return currentTime - preQueueTime;\n  };\n  /**\r\n   * Adds queue measurement time to QueueMeasurements array for given correlation ID.\r\n   *\r\n   * @param {PerformanceEvents} eventName\r\n   * @param {?string} correlationId\r\n   * @param {?number} queueTime\r\n   * @param {?boolean} manuallyCompleted - indicator for manually completed queue measurements\r\n   * @returns\r\n   */\n\n\n  PerformanceClient.prototype.addQueueMeasurement = function (eventName, correlationId, queueTime, manuallyCompleted) {\n    if (!correlationId) {\n      this.logger.trace(\"PerformanceClient.addQueueMeasurement: correlationId not provided for \" + eventName + \", cannot add queue measurement\");\n      return;\n    }\n\n    if (queueTime === 0) {\n      // Possible for there to be no queue time after calculation\n      this.logger.trace(\"PerformanceClient.addQueueMeasurement: queue time provided for \" + eventName + \" is \" + queueTime);\n    } else if (!queueTime) {\n      this.logger.trace(\"PerformanceClient.addQueueMeasurement: no queue time provided for \" + eventName);\n      return;\n    }\n\n    var queueMeasurement = {\n      eventName: eventName,\n      queueTime: queueTime,\n      manuallyCompleted: manuallyCompleted\n    }; // Adds to existing correlation Id if present in queueMeasurements\n\n    var existingMeasurements = this.queueMeasurements.get(correlationId);\n\n    if (existingMeasurements) {\n      existingMeasurements.push(queueMeasurement);\n      this.queueMeasurements.set(correlationId, existingMeasurements);\n    } else {\n      // Sets new correlation Id if not present in queueMeasurements\n      this.logger.trace(\"PerformanceClient.addQueueMeasurement: adding correlationId \" + correlationId + \" to queue measurements\");\n      var measurementArray = [queueMeasurement];\n      this.queueMeasurements.set(correlationId, measurementArray);\n    } // Delete processed pre-queue event.\n\n\n    this.preQueueTimeByCorrelationId.delete(correlationId);\n  };\n  /**\r\n   * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.\r\n   *\r\n   * @param {PerformanceEvents} measureName\r\n   * @param {?string} [correlationId]\r\n   * @returns {InProgressPerformanceEvent}\r\n   */\n\n\n  PerformanceClient.prototype.startMeasurement = function (measureName, correlationId) {\n    var _this = this;\n\n    var _a, _b; // Generate a placeholder correlation if the request does not provide one\n\n\n    var eventCorrelationId = correlationId || this.generateId();\n\n    if (!correlationId) {\n      this.logger.info(\"PerformanceClient: No correlation id provided for \" + measureName + \", generating\", eventCorrelationId);\n    } // Duplicate code to address spelling error will be removed at the next major version bump.\n\n\n    this.logger.trace(\"PerformanceClient: Performance measurement started for \" + measureName, eventCorrelationId);\n    var performanceMeasurement = this.startPerformanceMeasuremeant(measureName, eventCorrelationId);\n    performanceMeasurement.startMeasurement();\n    var inProgressEvent = {\n      eventId: this.generateId(),\n      status: PerformanceEventStatus.InProgress,\n      authority: this.authority,\n      libraryName: this.libraryName,\n      libraryVersion: this.libraryVersion,\n      clientId: this.clientId,\n      name: measureName,\n      startTimeMs: Date.now(),\n      correlationId: eventCorrelationId,\n      appName: (_a = this.applicationTelemetry) === null || _a === void 0 ? void 0 : _a.appName,\n      appVersion: (_b = this.applicationTelemetry) === null || _b === void 0 ? void 0 : _b.appVersion\n    }; // Store in progress events so they can be discarded if not ended properly\n\n    this.cacheEventByCorrelationId(inProgressEvent); // Return the event and functions the caller can use to properly end/flush the measurement\n\n    return {\n      endMeasurement: function (event) {\n        return _this.endMeasurement(__assign(__assign({}, inProgressEvent), event), performanceMeasurement);\n      },\n      discardMeasurement: function () {\n        return _this.discardMeasurements(inProgressEvent.correlationId);\n      },\n      addStaticFields: function (fields) {\n        return _this.addStaticFields(fields, inProgressEvent.correlationId);\n      },\n      increment: function (counters) {\n        return _this.increment(counters, inProgressEvent.correlationId);\n      },\n      measurement: performanceMeasurement,\n      event: inProgressEvent\n    };\n  };\n  /**\r\n   * Stops measuring the performance for an operation. Should only be called directly by PerformanceClient classes,\r\n   * as consumers should instead use the function returned by startMeasurement.\r\n   * Adds a new field named as \"[event name]DurationMs\" for sub-measurements, completes and emits an event\r\n   * otherwise.\r\n   *\r\n   * @param {PerformanceEvent} event\r\n   * @param {IPerformanceMeasurement} measurement\r\n   * @returns {(PerformanceEvent | null)}\r\n   */\n\n\n  PerformanceClient.prototype.endMeasurement = function (event, measurement) {\n    var _this = this;\n\n    var _a, _b;\n\n    var rootEvent = this.eventsByCorrelationId.get(event.correlationId);\n\n    if (!rootEvent) {\n      this.logger.trace(\"PerformanceClient: Measurement not found for \" + event.eventId, event.correlationId);\n      return null;\n    }\n\n    var isRoot = event.eventId === rootEvent.eventId;\n    var queueInfo = {\n      totalQueueTime: 0,\n      totalQueueCount: 0,\n      manuallyCompletedCount: 0\n    };\n\n    if (isRoot) {\n      queueInfo = this.getQueueInfo(event.correlationId);\n      this.discardCache(rootEvent.correlationId);\n    } else {\n      (_a = rootEvent.incompleteSubMeasurements) === null || _a === void 0 ? void 0 : _a.delete(event.eventId);\n    }\n\n    measurement === null || measurement === void 0 ? void 0 : measurement.endMeasurement();\n    var durationMs = measurement === null || measurement === void 0 ? void 0 : measurement.flushMeasurement(); // null indicates no measurement was taken (e.g. needed performance APIs not present)\n\n    if (!durationMs) {\n      this.logger.trace(\"PerformanceClient: Performance measurement not taken\", rootEvent.correlationId);\n      return null;\n    }\n\n    this.logger.trace(\"PerformanceClient: Performance measurement ended for \" + event.name + \": \" + durationMs + \" ms\", event.correlationId); // Add sub-measurement attribute to root event.\n\n    if (!isRoot) {\n      rootEvent[event.name + \"DurationMs\"] = Math.floor(durationMs);\n      return __assign({}, rootEvent);\n    }\n\n    var finalEvent = __assign(__assign({}, rootEvent), event);\n\n    var incompleteSubsCount = 0; // Incomplete sub-measurements are discarded. They are likely an instrumentation bug that should be fixed.\n\n    (_b = finalEvent.incompleteSubMeasurements) === null || _b === void 0 ? void 0 : _b.forEach(function (subMeasurement) {\n      _this.logger.trace(\"PerformanceClient: Incomplete submeasurement \" + subMeasurement.name + \" found for \" + event.name, finalEvent.correlationId);\n\n      incompleteSubsCount++;\n    });\n    finalEvent.incompleteSubMeasurements = undefined;\n    finalEvent = __assign(__assign({}, finalEvent), {\n      durationMs: Math.round(durationMs),\n      queuedTimeMs: queueInfo.totalQueueTime,\n      queuedCount: queueInfo.totalQueueCount,\n      queuedManuallyCompletedCount: queueInfo.manuallyCompletedCount,\n      status: PerformanceEventStatus.Completed,\n      incompleteSubsCount: incompleteSubsCount\n    });\n    this.truncateIntegralFields(finalEvent, this.getIntFields());\n    this.emitEvents([finalEvent], event.correlationId);\n    return finalEvent;\n  };\n  /**\r\n   * Saves extra information to be emitted when the measurements are flushed\r\n   * @param fields\r\n   * @param correlationId\r\n   */\n\n\n  PerformanceClient.prototype.addStaticFields = function (fields, correlationId) {\n    this.logger.trace(\"PerformanceClient: Updating static fields\");\n    var event = this.eventsByCorrelationId.get(correlationId);\n\n    if (event) {\n      this.eventsByCorrelationId.set(correlationId, __assign(__assign({}, event), fields));\n    } else {\n      this.logger.trace(\"PerformanceClient: Event not found for\", correlationId);\n    }\n  };\n  /**\r\n   * Increment counters to be emitted when the measurements are flushed\r\n   * @param counters {Counters}\r\n   * @param correlationId {string} correlation identifier\r\n   */\n\n\n  PerformanceClient.prototype.increment = function (counters, correlationId) {\n    this.logger.trace(\"PerformanceClient: Updating counters\");\n    var event = this.eventsByCorrelationId.get(correlationId);\n\n    if (event) {\n      for (var counter in counters) {\n        if (!event.hasOwnProperty(counter)) {\n          event[counter] = 0;\n        }\n\n        event[counter] += counters[counter];\n      }\n    } else {\n      this.logger.trace(\"PerformanceClient: Event not found for\", correlationId);\n    }\n  };\n  /**\r\n   * Upserts event into event cache.\r\n   * First key is the correlation id, second key is the event id.\r\n   * Allows for events to be grouped by correlation id,\r\n   * and to easily allow for properties on them to be updated.\r\n   *\r\n   * @private\r\n   * @param {PerformanceEvent} event\r\n   */\n\n\n  PerformanceClient.prototype.cacheEventByCorrelationId = function (event) {\n    var rootEvent = this.eventsByCorrelationId.get(event.correlationId);\n\n    if (rootEvent) {\n      this.logger.trace(\"PerformanceClient: Performance measurement for \" + event.name + \" added/updated\", event.correlationId);\n      rootEvent.incompleteSubMeasurements = rootEvent.incompleteSubMeasurements || new Map();\n      rootEvent.incompleteSubMeasurements.set(event.eventId, {\n        name: event.name,\n        startTimeMs: event.startTimeMs\n      });\n    } else {\n      this.logger.trace(\"PerformanceClient: Performance measurement for \" + event.name + \" started\", event.correlationId);\n      this.eventsByCorrelationId.set(event.correlationId, __assign({}, event));\n    }\n  };\n\n  PerformanceClient.prototype.getQueueInfo = function (correlationId) {\n    var queueMeasurementForCorrelationId = this.queueMeasurements.get(correlationId);\n\n    if (!queueMeasurementForCorrelationId) {\n      this.logger.trace(\"PerformanceClient: no queue measurements found for for correlationId: \" + correlationId);\n    }\n\n    var totalQueueTime = 0;\n    var totalQueueCount = 0;\n    var manuallyCompletedCount = 0;\n    queueMeasurementForCorrelationId === null || queueMeasurementForCorrelationId === void 0 ? void 0 : queueMeasurementForCorrelationId.forEach(function (measurement) {\n      totalQueueTime += measurement.queueTime;\n      totalQueueCount++;\n      manuallyCompletedCount += measurement.manuallyCompleted ? 1 : 0;\n    });\n    return {\n      totalQueueTime: totalQueueTime,\n      totalQueueCount: totalQueueCount,\n      manuallyCompletedCount: manuallyCompletedCount\n    };\n  };\n  /**\r\n   * Removes measurements for a given correlation id.\r\n   *\r\n   * @param {string} correlationId\r\n   */\n\n\n  PerformanceClient.prototype.discardMeasurements = function (correlationId) {\n    this.logger.trace(\"PerformanceClient: Performance measurements discarded\", correlationId);\n    this.eventsByCorrelationId.delete(correlationId);\n  };\n  /**\r\n   * Removes cache for a given correlation id.\r\n   *\r\n   * @param {string} correlationId correlation identifier\r\n   */\n\n\n  PerformanceClient.prototype.discardCache = function (correlationId) {\n    this.discardMeasurements(correlationId);\n    this.logger.trace(\"PerformanceClient: QueueMeasurements discarded\", correlationId);\n    this.queueMeasurements.delete(correlationId);\n    this.logger.trace(\"PerformanceClient: Pre-queue times discarded\", correlationId);\n    this.preQueueTimeByCorrelationId.delete(correlationId);\n  };\n  /**\r\n   * Registers a callback function to receive performance events.\r\n   *\r\n   * @param {PerformanceCallbackFunction} callback\r\n   * @returns {string}\r\n   */\n\n\n  PerformanceClient.prototype.addPerformanceCallback = function (callback) {\n    var callbackId = this.generateId();\n    this.callbacks.set(callbackId, callback);\n    this.logger.verbose(\"PerformanceClient: Performance callback registered with id: \" + callbackId);\n    return callbackId;\n  };\n  /**\r\n   * Removes a callback registered with addPerformanceCallback.\r\n   *\r\n   * @param {string} callbackId\r\n   * @returns {boolean}\r\n   */\n\n\n  PerformanceClient.prototype.removePerformanceCallback = function (callbackId) {\n    var result = this.callbacks.delete(callbackId);\n\n    if (result) {\n      this.logger.verbose(\"PerformanceClient: Performance callback \" + callbackId + \" removed.\");\n    } else {\n      this.logger.verbose(\"PerformanceClient: Performance callback \" + callbackId + \" not removed.\");\n    }\n\n    return result;\n  };\n  /**\r\n   * Emits events to all registered callbacks.\r\n   *\r\n   * @param {PerformanceEvent[]} events\r\n   * @param {?string} [correlationId]\r\n   */\n\n\n  PerformanceClient.prototype.emitEvents = function (events, correlationId) {\n    var _this = this;\n\n    this.logger.verbose(\"PerformanceClient: Emitting performance events\", correlationId);\n    this.callbacks.forEach(function (callback, callbackId) {\n      _this.logger.trace(\"PerformanceClient: Emitting event to callback \" + callbackId, correlationId);\n\n      callback.apply(null, [events]);\n    });\n  };\n  /**\r\n   * Enforce truncation of integral fields in performance event.\r\n   * @param {PerformanceEvent} event performance event to update.\r\n   * @param {Set<string>} intFields integral fields.\r\n   */\n\n\n  PerformanceClient.prototype.truncateIntegralFields = function (event, intFields) {\n    intFields.forEach(function (key) {\n      if (key in event && typeof event[key] === \"number\") {\n        event[key] = Math.floor(event[key]);\n      }\n    });\n  };\n\n  return PerformanceClient;\n}();\n\nexport { PerformanceClient };","map":{"version":3,"names":["__assign","IntFields","PerformanceEventStatus","PerformanceClient","clientId","authority","logger","libraryName","libraryVersion","applicationTelemetry","callbacks","Map","eventsByCorrelationId","queueMeasurements","preQueueTimeByCorrelationId","prototype","startPerformanceMeasurement","measureName","correlationId","startPerformanceMeasuremeant","getIntFields","getPreQueueTime","eventName","preQueueEvent","get","trace","name","time","calculateQueuedTime","preQueueTime","currentTime","addQueueMeasurement","queueTime","manuallyCompleted","queueMeasurement","existingMeasurements","push","set","measurementArray","delete","startMeasurement","_this","_a","_b","eventCorrelationId","generateId","info","performanceMeasurement","inProgressEvent","eventId","status","InProgress","startTimeMs","Date","now","appName","appVersion","cacheEventByCorrelationId","endMeasurement","event","discardMeasurement","discardMeasurements","addStaticFields","fields","increment","counters","measurement","rootEvent","isRoot","queueInfo","totalQueueTime","totalQueueCount","manuallyCompletedCount","getQueueInfo","discardCache","incompleteSubMeasurements","durationMs","flushMeasurement","Math","floor","finalEvent","incompleteSubsCount","forEach","subMeasurement","undefined","round","queuedTimeMs","queuedCount","queuedManuallyCompletedCount","Completed","truncateIntegralFields","emitEvents","counter","hasOwnProperty","queueMeasurementForCorrelationId","addPerformanceCallback","callback","callbackId","verbose","removePerformanceCallback","result","events","apply","intFields","key"],"sources":["F:/Bovis/Front/bovis-dev/node_modules/@azure/msal-common/dist/telemetry/performance/PerformanceClient.js"],"sourcesContent":["/*! @azure/msal-common v13.3.1 2023-10-27 */\n'use strict';\nimport { __assign } from '../../_virtual/_tslib.js';\nimport { IntFields, PerformanceEventStatus } from './PerformanceEvent.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nvar PerformanceClient = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of PerformanceClient,\r\n     * an abstract class containing core performance telemetry logic.\r\n     *\r\n     * @constructor\r\n     * @param {string} clientId Client ID of the application\r\n     * @param {string} authority Authority used by the application\r\n     * @param {Logger} logger Logger used by the application\r\n     * @param {string} libraryName Name of the library\r\n     * @param {string} libraryVersion Version of the library\r\n     */\r\n    function PerformanceClient(clientId, authority, logger, libraryName, libraryVersion, applicationTelemetry) {\r\n        this.authority = authority;\r\n        this.libraryName = libraryName;\r\n        this.libraryVersion = libraryVersion;\r\n        this.applicationTelemetry = applicationTelemetry;\r\n        this.clientId = clientId;\r\n        this.logger = logger;\r\n        this.callbacks = new Map();\r\n        this.eventsByCorrelationId = new Map();\r\n        this.queueMeasurements = new Map();\r\n        this.preQueueTimeByCorrelationId = new Map();\r\n    }\r\n    /**\r\n     * Starts and returns an platform-specific implementation of IPerformanceMeasurement.\r\n     * Note: this function can be changed to abstract at the next major version bump.\r\n     *\r\n     * @param {string} measureName\r\n     * @param {string} correlationId\r\n     * @returns {IPerformanceMeasurement}\r\n     */\r\n    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\r\n    PerformanceClient.prototype.startPerformanceMeasurement = function (measureName, correlationId) {\r\n        return {};\r\n    };\r\n    /**\r\n     * Starts and returns an platform-specific implementation of IPerformanceMeasurement.\r\n     * Note: this incorrectly-named function will be removed at the next major version bump.\r\n     *\r\n     * @param {string} measureName\r\n     * @param {string} correlationId\r\n     * @returns {IPerformanceMeasurement}\r\n     */\r\n    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\r\n    PerformanceClient.prototype.startPerformanceMeasuremeant = function (measureName, correlationId) {\r\n        return {};\r\n    };\r\n    /**\r\n     * Get integral fields.\r\n     * Override to change the set.\r\n     */\r\n    PerformanceClient.prototype.getIntFields = function () {\r\n        return IntFields;\r\n    };\r\n    /**\r\n     * Gets map of pre-queue times by correlation Id\r\n     *\r\n     * @param {PerformanceEvents} eventName\r\n     * @param {string} correlationId\r\n     * @returns {number}\r\n     */\r\n    PerformanceClient.prototype.getPreQueueTime = function (eventName, correlationId) {\r\n        var preQueueEvent = this.preQueueTimeByCorrelationId.get(correlationId);\r\n        if (!preQueueEvent) {\r\n            this.logger.trace(\"PerformanceClient.getPreQueueTime: no pre-queue times found for correlationId: \" + correlationId + \", unable to add queue measurement\");\r\n            return;\r\n        }\r\n        else if (preQueueEvent.name !== eventName) {\r\n            this.logger.trace(\"PerformanceClient.getPreQueueTime: no pre-queue time found for \" + eventName + \", unable to add queue measurement\");\r\n            return;\r\n        }\r\n        return preQueueEvent.time;\r\n    };\r\n    /**\r\n     * Calculates the difference between current time and time when function was queued.\r\n     * Note: It is possible to have 0 as the queue time if the current time and the queued time was the same.\r\n     *\r\n     * @param {number} preQueueTime\r\n     * @param {number} currentTime\r\n     * @returns {number}\r\n     */\r\n    PerformanceClient.prototype.calculateQueuedTime = function (preQueueTime, currentTime) {\r\n        if (preQueueTime < 1) {\r\n            this.logger.trace(\"PerformanceClient: preQueueTime should be a positive integer and not \" + preQueueTime);\r\n            return 0;\r\n        }\r\n        if (currentTime < 1) {\r\n            this.logger.trace(\"PerformanceClient: currentTime should be a positive integer and not \" + currentTime);\r\n            return 0;\r\n        }\r\n        if (currentTime < preQueueTime) {\r\n            this.logger.trace(\"PerformanceClient: currentTime is less than preQueueTime, check how time is being retrieved\");\r\n            return 0;\r\n        }\r\n        return currentTime - preQueueTime;\r\n    };\r\n    /**\r\n     * Adds queue measurement time to QueueMeasurements array for given correlation ID.\r\n     *\r\n     * @param {PerformanceEvents} eventName\r\n     * @param {?string} correlationId\r\n     * @param {?number} queueTime\r\n     * @param {?boolean} manuallyCompleted - indicator for manually completed queue measurements\r\n     * @returns\r\n     */\r\n    PerformanceClient.prototype.addQueueMeasurement = function (eventName, correlationId, queueTime, manuallyCompleted) {\r\n        if (!correlationId) {\r\n            this.logger.trace(\"PerformanceClient.addQueueMeasurement: correlationId not provided for \" + eventName + \", cannot add queue measurement\");\r\n            return;\r\n        }\r\n        if (queueTime === 0) {\r\n            // Possible for there to be no queue time after calculation\r\n            this.logger.trace(\"PerformanceClient.addQueueMeasurement: queue time provided for \" + eventName + \" is \" + queueTime);\r\n        }\r\n        else if (!queueTime) {\r\n            this.logger.trace(\"PerformanceClient.addQueueMeasurement: no queue time provided for \" + eventName);\r\n            return;\r\n        }\r\n        var queueMeasurement = { eventName: eventName, queueTime: queueTime, manuallyCompleted: manuallyCompleted };\r\n        // Adds to existing correlation Id if present in queueMeasurements\r\n        var existingMeasurements = this.queueMeasurements.get(correlationId);\r\n        if (existingMeasurements) {\r\n            existingMeasurements.push(queueMeasurement);\r\n            this.queueMeasurements.set(correlationId, existingMeasurements);\r\n        }\r\n        else {\r\n            // Sets new correlation Id if not present in queueMeasurements\r\n            this.logger.trace(\"PerformanceClient.addQueueMeasurement: adding correlationId \" + correlationId + \" to queue measurements\");\r\n            var measurementArray = [queueMeasurement];\r\n            this.queueMeasurements.set(correlationId, measurementArray);\r\n        }\r\n        // Delete processed pre-queue event.\r\n        this.preQueueTimeByCorrelationId.delete(correlationId);\r\n    };\r\n    /**\r\n     * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.\r\n     *\r\n     * @param {PerformanceEvents} measureName\r\n     * @param {?string} [correlationId]\r\n     * @returns {InProgressPerformanceEvent}\r\n     */\r\n    PerformanceClient.prototype.startMeasurement = function (measureName, correlationId) {\r\n        var _this = this;\r\n        var _a, _b;\r\n        // Generate a placeholder correlation if the request does not provide one\r\n        var eventCorrelationId = correlationId || this.generateId();\r\n        if (!correlationId) {\r\n            this.logger.info(\"PerformanceClient: No correlation id provided for \" + measureName + \", generating\", eventCorrelationId);\r\n        }\r\n        // Duplicate code to address spelling error will be removed at the next major version bump.\r\n        this.logger.trace(\"PerformanceClient: Performance measurement started for \" + measureName, eventCorrelationId);\r\n        var performanceMeasurement = this.startPerformanceMeasuremeant(measureName, eventCorrelationId);\r\n        performanceMeasurement.startMeasurement();\r\n        var inProgressEvent = {\r\n            eventId: this.generateId(),\r\n            status: PerformanceEventStatus.InProgress,\r\n            authority: this.authority,\r\n            libraryName: this.libraryName,\r\n            libraryVersion: this.libraryVersion,\r\n            clientId: this.clientId,\r\n            name: measureName,\r\n            startTimeMs: Date.now(),\r\n            correlationId: eventCorrelationId,\r\n            appName: (_a = this.applicationTelemetry) === null || _a === void 0 ? void 0 : _a.appName,\r\n            appVersion: (_b = this.applicationTelemetry) === null || _b === void 0 ? void 0 : _b.appVersion,\r\n        };\r\n        // Store in progress events so they can be discarded if not ended properly\r\n        this.cacheEventByCorrelationId(inProgressEvent);\r\n        // Return the event and functions the caller can use to properly end/flush the measurement\r\n        return {\r\n            endMeasurement: function (event) {\r\n                return _this.endMeasurement(__assign(__assign({}, inProgressEvent), event), performanceMeasurement);\r\n            },\r\n            discardMeasurement: function () {\r\n                return _this.discardMeasurements(inProgressEvent.correlationId);\r\n            },\r\n            addStaticFields: function (fields) {\r\n                return _this.addStaticFields(fields, inProgressEvent.correlationId);\r\n            },\r\n            increment: function (counters) {\r\n                return _this.increment(counters, inProgressEvent.correlationId);\r\n            },\r\n            measurement: performanceMeasurement,\r\n            event: inProgressEvent\r\n        };\r\n    };\r\n    /**\r\n     * Stops measuring the performance for an operation. Should only be called directly by PerformanceClient classes,\r\n     * as consumers should instead use the function returned by startMeasurement.\r\n     * Adds a new field named as \"[event name]DurationMs\" for sub-measurements, completes and emits an event\r\n     * otherwise.\r\n     *\r\n     * @param {PerformanceEvent} event\r\n     * @param {IPerformanceMeasurement} measurement\r\n     * @returns {(PerformanceEvent | null)}\r\n     */\r\n    PerformanceClient.prototype.endMeasurement = function (event, measurement) {\r\n        var _this = this;\r\n        var _a, _b;\r\n        var rootEvent = this.eventsByCorrelationId.get(event.correlationId);\r\n        if (!rootEvent) {\r\n            this.logger.trace(\"PerformanceClient: Measurement not found for \" + event.eventId, event.correlationId);\r\n            return null;\r\n        }\r\n        var isRoot = event.eventId === rootEvent.eventId;\r\n        var queueInfo = {\r\n            totalQueueTime: 0,\r\n            totalQueueCount: 0,\r\n            manuallyCompletedCount: 0\r\n        };\r\n        if (isRoot) {\r\n            queueInfo = this.getQueueInfo(event.correlationId);\r\n            this.discardCache(rootEvent.correlationId);\r\n        }\r\n        else {\r\n            (_a = rootEvent.incompleteSubMeasurements) === null || _a === void 0 ? void 0 : _a.delete(event.eventId);\r\n        }\r\n        measurement === null || measurement === void 0 ? void 0 : measurement.endMeasurement();\r\n        var durationMs = measurement === null || measurement === void 0 ? void 0 : measurement.flushMeasurement();\r\n        // null indicates no measurement was taken (e.g. needed performance APIs not present)\r\n        if (!durationMs) {\r\n            this.logger.trace(\"PerformanceClient: Performance measurement not taken\", rootEvent.correlationId);\r\n            return null;\r\n        }\r\n        this.logger.trace(\"PerformanceClient: Performance measurement ended for \" + event.name + \": \" + durationMs + \" ms\", event.correlationId);\r\n        // Add sub-measurement attribute to root event.\r\n        if (!isRoot) {\r\n            rootEvent[event.name + \"DurationMs\"] = Math.floor(durationMs);\r\n            return __assign({}, rootEvent);\r\n        }\r\n        var finalEvent = __assign(__assign({}, rootEvent), event);\r\n        var incompleteSubsCount = 0;\r\n        // Incomplete sub-measurements are discarded. They are likely an instrumentation bug that should be fixed.\r\n        (_b = finalEvent.incompleteSubMeasurements) === null || _b === void 0 ? void 0 : _b.forEach(function (subMeasurement) {\r\n            _this.logger.trace(\"PerformanceClient: Incomplete submeasurement \" + subMeasurement.name + \" found for \" + event.name, finalEvent.correlationId);\r\n            incompleteSubsCount++;\r\n        });\r\n        finalEvent.incompleteSubMeasurements = undefined;\r\n        finalEvent = __assign(__assign({}, finalEvent), { durationMs: Math.round(durationMs), queuedTimeMs: queueInfo.totalQueueTime, queuedCount: queueInfo.totalQueueCount, queuedManuallyCompletedCount: queueInfo.manuallyCompletedCount, status: PerformanceEventStatus.Completed, incompleteSubsCount: incompleteSubsCount });\r\n        this.truncateIntegralFields(finalEvent, this.getIntFields());\r\n        this.emitEvents([finalEvent], event.correlationId);\r\n        return finalEvent;\r\n    };\r\n    /**\r\n     * Saves extra information to be emitted when the measurements are flushed\r\n     * @param fields\r\n     * @param correlationId\r\n     */\r\n    PerformanceClient.prototype.addStaticFields = function (fields, correlationId) {\r\n        this.logger.trace(\"PerformanceClient: Updating static fields\");\r\n        var event = this.eventsByCorrelationId.get(correlationId);\r\n        if (event) {\r\n            this.eventsByCorrelationId.set(correlationId, __assign(__assign({}, event), fields));\r\n        }\r\n        else {\r\n            this.logger.trace(\"PerformanceClient: Event not found for\", correlationId);\r\n        }\r\n    };\r\n    /**\r\n     * Increment counters to be emitted when the measurements are flushed\r\n     * @param counters {Counters}\r\n     * @param correlationId {string} correlation identifier\r\n     */\r\n    PerformanceClient.prototype.increment = function (counters, correlationId) {\r\n        this.logger.trace(\"PerformanceClient: Updating counters\");\r\n        var event = this.eventsByCorrelationId.get(correlationId);\r\n        if (event) {\r\n            for (var counter in counters) {\r\n                if (!event.hasOwnProperty(counter)) {\r\n                    event[counter] = 0;\r\n                }\r\n                event[counter] += counters[counter];\r\n            }\r\n        }\r\n        else {\r\n            this.logger.trace(\"PerformanceClient: Event not found for\", correlationId);\r\n        }\r\n    };\r\n    /**\r\n     * Upserts event into event cache.\r\n     * First key is the correlation id, second key is the event id.\r\n     * Allows for events to be grouped by correlation id,\r\n     * and to easily allow for properties on them to be updated.\r\n     *\r\n     * @private\r\n     * @param {PerformanceEvent} event\r\n     */\r\n    PerformanceClient.prototype.cacheEventByCorrelationId = function (event) {\r\n        var rootEvent = this.eventsByCorrelationId.get(event.correlationId);\r\n        if (rootEvent) {\r\n            this.logger.trace(\"PerformanceClient: Performance measurement for \" + event.name + \" added/updated\", event.correlationId);\r\n            rootEvent.incompleteSubMeasurements = rootEvent.incompleteSubMeasurements || new Map();\r\n            rootEvent.incompleteSubMeasurements.set(event.eventId, { name: event.name, startTimeMs: event.startTimeMs });\r\n        }\r\n        else {\r\n            this.logger.trace(\"PerformanceClient: Performance measurement for \" + event.name + \" started\", event.correlationId);\r\n            this.eventsByCorrelationId.set(event.correlationId, __assign({}, event));\r\n        }\r\n    };\r\n    PerformanceClient.prototype.getQueueInfo = function (correlationId) {\r\n        var queueMeasurementForCorrelationId = this.queueMeasurements.get(correlationId);\r\n        if (!queueMeasurementForCorrelationId) {\r\n            this.logger.trace(\"PerformanceClient: no queue measurements found for for correlationId: \" + correlationId);\r\n        }\r\n        var totalQueueTime = 0;\r\n        var totalQueueCount = 0;\r\n        var manuallyCompletedCount = 0;\r\n        queueMeasurementForCorrelationId === null || queueMeasurementForCorrelationId === void 0 ? void 0 : queueMeasurementForCorrelationId.forEach(function (measurement) {\r\n            totalQueueTime += measurement.queueTime;\r\n            totalQueueCount++;\r\n            manuallyCompletedCount += measurement.manuallyCompleted ? 1 : 0;\r\n        });\r\n        return {\r\n            totalQueueTime: totalQueueTime,\r\n            totalQueueCount: totalQueueCount,\r\n            manuallyCompletedCount: manuallyCompletedCount\r\n        };\r\n    };\r\n    /**\r\n     * Removes measurements for a given correlation id.\r\n     *\r\n     * @param {string} correlationId\r\n     */\r\n    PerformanceClient.prototype.discardMeasurements = function (correlationId) {\r\n        this.logger.trace(\"PerformanceClient: Performance measurements discarded\", correlationId);\r\n        this.eventsByCorrelationId.delete(correlationId);\r\n    };\r\n    /**\r\n     * Removes cache for a given correlation id.\r\n     *\r\n     * @param {string} correlationId correlation identifier\r\n     */\r\n    PerformanceClient.prototype.discardCache = function (correlationId) {\r\n        this.discardMeasurements(correlationId);\r\n        this.logger.trace(\"PerformanceClient: QueueMeasurements discarded\", correlationId);\r\n        this.queueMeasurements.delete(correlationId);\r\n        this.logger.trace(\"PerformanceClient: Pre-queue times discarded\", correlationId);\r\n        this.preQueueTimeByCorrelationId.delete(correlationId);\r\n    };\r\n    /**\r\n     * Registers a callback function to receive performance events.\r\n     *\r\n     * @param {PerformanceCallbackFunction} callback\r\n     * @returns {string}\r\n     */\r\n    PerformanceClient.prototype.addPerformanceCallback = function (callback) {\r\n        var callbackId = this.generateId();\r\n        this.callbacks.set(callbackId, callback);\r\n        this.logger.verbose(\"PerformanceClient: Performance callback registered with id: \" + callbackId);\r\n        return callbackId;\r\n    };\r\n    /**\r\n     * Removes a callback registered with addPerformanceCallback.\r\n     *\r\n     * @param {string} callbackId\r\n     * @returns {boolean}\r\n     */\r\n    PerformanceClient.prototype.removePerformanceCallback = function (callbackId) {\r\n        var result = this.callbacks.delete(callbackId);\r\n        if (result) {\r\n            this.logger.verbose(\"PerformanceClient: Performance callback \" + callbackId + \" removed.\");\r\n        }\r\n        else {\r\n            this.logger.verbose(\"PerformanceClient: Performance callback \" + callbackId + \" not removed.\");\r\n        }\r\n        return result;\r\n    };\r\n    /**\r\n     * Emits events to all registered callbacks.\r\n     *\r\n     * @param {PerformanceEvent[]} events\r\n     * @param {?string} [correlationId]\r\n     */\r\n    PerformanceClient.prototype.emitEvents = function (events, correlationId) {\r\n        var _this = this;\r\n        this.logger.verbose(\"PerformanceClient: Emitting performance events\", correlationId);\r\n        this.callbacks.forEach(function (callback, callbackId) {\r\n            _this.logger.trace(\"PerformanceClient: Emitting event to callback \" + callbackId, correlationId);\r\n            callback.apply(null, [events]);\r\n        });\r\n    };\r\n    /**\r\n     * Enforce truncation of integral fields in performance event.\r\n     * @param {PerformanceEvent} event performance event to update.\r\n     * @param {Set<string>} intFields integral fields.\r\n     */\r\n    PerformanceClient.prototype.truncateIntegralFields = function (event, intFields) {\r\n        intFields.forEach(function (key) {\r\n            if (key in event && typeof event[key] === \"number\") {\r\n                event[key] = Math.floor(event[key]);\r\n            }\r\n        });\r\n    };\r\n    return PerformanceClient;\r\n}());\n\nexport { PerformanceClient };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}