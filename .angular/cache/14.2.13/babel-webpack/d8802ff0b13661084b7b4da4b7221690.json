{"ast":null,"code":"/*! @azure/msal-browser v2.38.3 2023-10-27 */\n'use strict';\n\nimport { __extends, __awaiter, __generator, __spread } from '../_virtual/_tslib.js';\nimport { CredentialType, RefreshTokenEntity, CacheManager, AccessTokenEntity, IdTokenEntity, AccountEntity, ClientAuthError, AppMetadataEntity, ServerTelemetryEntity, AuthorityMetadataEntity, Constants, PersistentCacheKeys, ThrottlingEntity, StringUtils, ProtocolUtils, CcsCredentialType, IdToken, DEFAULT_CRYPTO_IMPLEMENTATION } from '@azure/msal-common';\nimport { BrowserAuthError } from '../error/BrowserAuthError.js';\nimport { BrowserCacheLocation, StaticCacheKeys, InMemoryCacheKeys, TemporaryCacheKeys } from '../utils/BrowserConstants.js';\nimport { BrowserStorage } from './BrowserStorage.js';\nimport { MemoryStorage } from './MemoryStorage.js';\nimport { BrowserProtocolUtils } from '../utils/BrowserProtocolUtils.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * This class implements the cache storage interface for MSAL through browser local or session storage.\r\n * Cookies are only used if storeAuthStateInCookie is true, and are only used for\r\n * parameters such as state and nonce, generally.\r\n */\n\nvar BrowserCacheManager =\n/** @class */\nfunction (_super) {\n  __extends(BrowserCacheManager, _super);\n\n  function BrowserCacheManager(clientId, cacheConfig, cryptoImpl, logger) {\n    var _this = _super.call(this, clientId, cryptoImpl, logger) || this; // Cookie life calculation (hours * minutes * seconds * ms)\n\n\n    _this.COOKIE_LIFE_MULTIPLIER = 24 * 60 * 60 * 1000;\n    _this.cacheConfig = cacheConfig;\n    _this.logger = logger;\n    _this.internalStorage = new MemoryStorage();\n    _this.browserStorage = _this.setupBrowserStorage(_this.cacheConfig.cacheLocation);\n    _this.temporaryCacheStorage = _this.setupTemporaryCacheStorage(_this.cacheConfig.temporaryCacheLocation, _this.cacheConfig.cacheLocation); // Migrate cache entries from older versions of MSAL.\n\n    if (cacheConfig.cacheMigrationEnabled) {\n      _this.migrateCacheEntries();\n\n      _this.createKeyMaps();\n    }\n\n    return _this;\n  }\n  /**\r\n   * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured cacheLocation.\r\n   * @param cacheLocation\r\n   */\n\n\n  BrowserCacheManager.prototype.setupBrowserStorage = function (cacheLocation) {\n    switch (cacheLocation) {\n      case BrowserCacheLocation.LocalStorage:\n      case BrowserCacheLocation.SessionStorage:\n        try {\n          return new BrowserStorage(cacheLocation);\n        } catch (e) {\n          this.logger.verbose(e);\n          break;\n        }\n\n    }\n\n    this.cacheConfig.cacheLocation = BrowserCacheLocation.MemoryStorage;\n    return new MemoryStorage();\n  };\n  /**\r\n   * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured temporaryCacheLocation.\r\n   * @param temporaryCacheLocation\r\n   * @param cacheLocation\r\n   */\n\n\n  BrowserCacheManager.prototype.setupTemporaryCacheStorage = function (temporaryCacheLocation, cacheLocation) {\n    switch (cacheLocation) {\n      case BrowserCacheLocation.LocalStorage:\n      case BrowserCacheLocation.SessionStorage:\n        try {\n          /*\r\n           * When users do not explicitly choose their own temporaryCacheLocation,\r\n           * temporary cache items will always be stored in session storage to mitigate problems caused by multiple tabs\r\n           */\n          return new BrowserStorage(temporaryCacheLocation || BrowserCacheLocation.SessionStorage);\n        } catch (e) {\n          this.logger.verbose(e);\n          return this.internalStorage;\n        }\n\n      case BrowserCacheLocation.MemoryStorage:\n      default:\n        return this.internalStorage;\n    }\n  };\n  /**\r\n   * Migrate all old cache entries to new schema. No rollback supported.\r\n   * @param storeAuthStateInCookie\r\n   */\n\n\n  BrowserCacheManager.prototype.migrateCacheEntries = function () {\n    var _this = this;\n\n    var idTokenKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.ID_TOKEN;\n    var clientInfoKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.CLIENT_INFO;\n    var errorKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.ERROR;\n    var errorDescKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.ERROR_DESC;\n    var idTokenValue = this.browserStorage.getItem(idTokenKey);\n    var clientInfoValue = this.browserStorage.getItem(clientInfoKey);\n    var errorValue = this.browserStorage.getItem(errorKey);\n    var errorDescValue = this.browserStorage.getItem(errorDescKey);\n    var values = [idTokenValue, clientInfoValue, errorValue, errorDescValue];\n    var keysToMigrate = [PersistentCacheKeys.ID_TOKEN, PersistentCacheKeys.CLIENT_INFO, PersistentCacheKeys.ERROR, PersistentCacheKeys.ERROR_DESC];\n    keysToMigrate.forEach(function (cacheKey, index) {\n      return _this.migrateCacheEntry(cacheKey, values[index]);\n    });\n  };\n  /**\r\n   * Utility function to help with migration.\r\n   * @param newKey\r\n   * @param value\r\n   * @param storeAuthStateInCookie\r\n   */\n\n\n  BrowserCacheManager.prototype.migrateCacheEntry = function (newKey, value) {\n    if (value) {\n      this.setTemporaryCache(newKey, value, true);\n    }\n  };\n  /**\r\n   * Searches all cache entries for MSAL accounts and creates the account key map\r\n   * This is used to migrate users from older versions of MSAL which did not create the map.\r\n   * @returns\r\n   */\n\n\n  BrowserCacheManager.prototype.createKeyMaps = function () {\n    var _this = this;\n\n    this.logger.trace(\"BrowserCacheManager - createKeyMaps called.\");\n    var accountKeys = this.getItem(StaticCacheKeys.ACCOUNT_KEYS);\n    var tokenKeys = this.getItem(StaticCacheKeys.TOKEN_KEYS + \".\" + this.clientId);\n\n    if (accountKeys && tokenKeys) {\n      this.logger.verbose(\"BrowserCacheManager:createKeyMaps - account and token key maps already exist, skipping migration.\"); // Key maps already exist, no need to iterate through cache\n\n      return;\n    }\n\n    var allKeys = this.browserStorage.getKeys();\n    allKeys.forEach(function (key) {\n      if (_this.isCredentialKey(key)) {\n        // Get item, parse, validate and write key to map\n        var value = _this.getItem(key);\n\n        if (value) {\n          var credObj = _this.validateAndParseJson(value);\n\n          if (credObj && credObj.hasOwnProperty(\"credentialType\")) {\n            switch (credObj[\"credentialType\"]) {\n              case CredentialType.ID_TOKEN:\n                if (IdTokenEntity.isIdTokenEntity(credObj)) {\n                  _this.logger.trace(\"BrowserCacheManager:createKeyMaps - idToken found, saving key to token key map\");\n\n                  _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - idToken with key: \" + key + \" found, saving key to token key map\");\n\n                  var idTokenEntity = CacheManager.toObject(new IdTokenEntity(), credObj);\n\n                  var newKey = _this.updateCredentialCacheKey(key, idTokenEntity);\n\n                  _this.addTokenKey(newKey, CredentialType.ID_TOKEN);\n\n                  return;\n                } else {\n                  _this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching idToken schema with value containing idToken credentialType field but value failed IdTokenEntity validation, skipping.\");\n\n                  _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - failed idToken validation on key: \" + key);\n                }\n\n                break;\n\n              case CredentialType.ACCESS_TOKEN:\n              case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\n                if (AccessTokenEntity.isAccessTokenEntity(credObj)) {\n                  _this.logger.trace(\"BrowserCacheManager:createKeyMaps - accessToken found, saving key to token key map\");\n\n                  _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - accessToken with key: \" + key + \" found, saving key to token key map\");\n\n                  var accessTokenEntity = CacheManager.toObject(new AccessTokenEntity(), credObj);\n\n                  var newKey = _this.updateCredentialCacheKey(key, accessTokenEntity);\n\n                  _this.addTokenKey(newKey, CredentialType.ACCESS_TOKEN);\n\n                  return;\n                } else {\n                  _this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching accessToken schema with value containing accessToken credentialType field but value failed AccessTokenEntity validation, skipping.\");\n\n                  _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - failed accessToken validation on key: \" + key);\n                }\n\n                break;\n\n              case CredentialType.REFRESH_TOKEN:\n                if (RefreshTokenEntity.isRefreshTokenEntity(credObj)) {\n                  _this.logger.trace(\"BrowserCacheManager:createKeyMaps - refreshToken found, saving key to token key map\");\n\n                  _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - refreshToken with key: \" + key + \" found, saving key to token key map\");\n\n                  var refreshTokenEntity = CacheManager.toObject(new RefreshTokenEntity(), credObj);\n\n                  var newKey = _this.updateCredentialCacheKey(key, refreshTokenEntity);\n\n                  _this.addTokenKey(newKey, CredentialType.REFRESH_TOKEN);\n\n                  return;\n                } else {\n                  _this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching refreshToken schema with value containing refreshToken credentialType field but value failed RefreshTokenEntity validation, skipping.\");\n\n                  _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - failed refreshToken validation on key: \" + key);\n                }\n\n                break;\n              // If credentialType isn't one of our predefined ones, it may not be an MSAL cache value. Ignore.\n            }\n          }\n        }\n      }\n\n      if (_this.isAccountKey(key)) {\n        var value = _this.getItem(key);\n\n        if (value) {\n          var accountObj = _this.validateAndParseJson(value);\n\n          if (accountObj && AccountEntity.isAccountEntity(accountObj)) {\n            _this.logger.trace(\"BrowserCacheManager:createKeyMaps - account found, saving key to account key map\");\n\n            _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - account with key: \" + key + \" found, saving key to account key map\");\n\n            _this.addAccountKeyToMap(key);\n          }\n        }\n      }\n    });\n  };\n  /**\r\n   * Parses passed value as JSON object, JSON.parse() will throw an error.\r\n   * @param input\r\n   */\n\n\n  BrowserCacheManager.prototype.validateAndParseJson = function (jsonValue) {\n    try {\n      var parsedJson = JSON.parse(jsonValue);\n      /**\r\n       * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\r\n       * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\r\n       * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\r\n       *\r\n       */\n\n      return parsedJson && typeof parsedJson === \"object\" ? parsedJson : null;\n    } catch (error) {\n      return null;\n    }\n  };\n  /**\r\n   * fetches the entry from the browser storage based off the key\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.getItem = function (key) {\n    return this.browserStorage.getItem(key);\n  };\n  /**\r\n   * sets the entry in the browser storage\r\n   * @param key\r\n   * @param value\r\n   */\n\n\n  BrowserCacheManager.prototype.setItem = function (key, value) {\n    this.browserStorage.setItem(key, value);\n  };\n  /**\r\n   * fetch the account entity from the platform cache\r\n   * @param accountKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getAccount = function (accountKey) {\n    this.logger.trace(\"BrowserCacheManager.getAccount called\");\n    var account = this.getItem(accountKey);\n\n    if (!account) {\n      this.removeAccountKeyFromMap(accountKey);\n      return null;\n    }\n\n    var parsedAccount = this.validateAndParseJson(account);\n\n    if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {\n      this.removeAccountKeyFromMap(accountKey);\n      return null;\n    }\n\n    return CacheManager.toObject(new AccountEntity(), parsedAccount);\n  };\n  /**\r\n   * set account entity in the platform cache\r\n   * @param key\r\n   * @param value\r\n   */\n\n\n  BrowserCacheManager.prototype.setAccount = function (account) {\n    this.logger.trace(\"BrowserCacheManager.setAccount called\");\n    var key = account.generateAccountKey();\n    this.setItem(key, JSON.stringify(account));\n    this.addAccountKeyToMap(key);\n  };\n  /**\r\n   * Returns the array of account keys currently cached\r\n   * @returns\r\n   */\n\n\n  BrowserCacheManager.prototype.getAccountKeys = function () {\n    this.logger.trace(\"BrowserCacheManager.getAccountKeys called\");\n    var accountKeys = this.getItem(StaticCacheKeys.ACCOUNT_KEYS);\n\n    if (accountKeys) {\n      return JSON.parse(accountKeys);\n    }\n\n    this.logger.verbose(\"BrowserCacheManager.getAccountKeys - No account keys found\");\n    return [];\n  };\n  /**\r\n   * Add a new account to the key map\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.addAccountKeyToMap = function (key) {\n    this.logger.trace(\"BrowserCacheManager.addAccountKeyToMap called\");\n    this.logger.tracePii(\"BrowserCacheManager.addAccountKeyToMap called with key: \" + key);\n    var accountKeys = this.getAccountKeys();\n\n    if (accountKeys.indexOf(key) === -1) {\n      // Only add key if it does not already exist in the map\n      accountKeys.push(key);\n      this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));\n      this.logger.verbose(\"BrowserCacheManager.addAccountKeyToMap account key added\");\n    } else {\n      this.logger.verbose(\"BrowserCacheManager.addAccountKeyToMap account key already exists in map\");\n    }\n  };\n  /**\r\n   * Remove an account from the key map\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.removeAccountKeyFromMap = function (key) {\n    this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap called\");\n    this.logger.tracePii(\"BrowserCacheManager.removeAccountKeyFromMap called with key: \" + key);\n    var accountKeys = this.getAccountKeys();\n    var removalIndex = accountKeys.indexOf(key);\n\n    if (removalIndex > -1) {\n      accountKeys.splice(removalIndex, 1);\n      this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));\n      this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap account key removed\");\n    } else {\n      this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap key not found in existing map\");\n    }\n  };\n  /**\r\n   * Extends inherited removeAccount function to include removal of the account key from the map\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.removeAccount = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        _super.prototype.removeAccount.call(this, key);\n\n        this.removeAccountKeyFromMap(key);\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /**\r\n   * Removes given idToken from the cache and from the key map\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.removeIdToken = function (key) {\n    _super.prototype.removeIdToken.call(this, key);\n\n    this.removeTokenKey(key, CredentialType.ID_TOKEN);\n  };\n  /**\r\n   * Removes given accessToken from the cache and from the key map\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.removeAccessToken = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        _super.prototype.removeAccessToken.call(this, key);\n\n        this.removeTokenKey(key, CredentialType.ACCESS_TOKEN);\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /**\r\n   * Removes given refreshToken from the cache and from the key map\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.removeRefreshToken = function (key) {\n    _super.prototype.removeRefreshToken.call(this, key);\n\n    this.removeTokenKey(key, CredentialType.REFRESH_TOKEN);\n  };\n  /**\r\n   * Gets the keys for the cached tokens associated with this clientId\r\n   * @returns\r\n   */\n\n\n  BrowserCacheManager.prototype.getTokenKeys = function () {\n    this.logger.trace(\"BrowserCacheManager.getTokenKeys called\");\n    var item = this.getItem(StaticCacheKeys.TOKEN_KEYS + \".\" + this.clientId);\n\n    if (item) {\n      var tokenKeys = this.validateAndParseJson(item);\n\n      if (tokenKeys && tokenKeys.hasOwnProperty(\"idToken\") && tokenKeys.hasOwnProperty(\"accessToken\") && tokenKeys.hasOwnProperty(\"refreshToken\")) {\n        return tokenKeys;\n      } else {\n        this.logger.error(\"BrowserCacheManager.getTokenKeys - Token keys found but in an unknown format. Returning empty key map.\");\n      }\n    } else {\n      this.logger.verbose(\"BrowserCacheManager.getTokenKeys - No token keys found\");\n    }\n\n    return {\n      idToken: [],\n      accessToken: [],\n      refreshToken: []\n    };\n  };\n  /**\r\n   * Adds the given key to the token key map\r\n   * @param key\r\n   * @param type\r\n   */\n\n\n  BrowserCacheManager.prototype.addTokenKey = function (key, type) {\n    this.logger.trace(\"BrowserCacheManager addTokenKey called\");\n    var tokenKeys = this.getTokenKeys();\n\n    switch (type) {\n      case CredentialType.ID_TOKEN:\n        if (tokenKeys.idToken.indexOf(key) === -1) {\n          this.logger.info(\"BrowserCacheManager: addTokenKey - idToken added to map\");\n          tokenKeys.idToken.push(key);\n        }\n\n        break;\n\n      case CredentialType.ACCESS_TOKEN:\n        if (tokenKeys.accessToken.indexOf(key) === -1) {\n          this.logger.info(\"BrowserCacheManager: addTokenKey - accessToken added to map\");\n          tokenKeys.accessToken.push(key);\n        }\n\n        break;\n\n      case CredentialType.REFRESH_TOKEN:\n        if (tokenKeys.refreshToken.indexOf(key) === -1) {\n          this.logger.info(\"BrowserCacheManager: addTokenKey - refreshToken added to map\");\n          tokenKeys.refreshToken.push(key);\n        }\n\n        break;\n\n      default:\n        this.logger.error(\"BrowserCacheManager:addTokenKey - CredentialType provided invalid. CredentialType: \" + type);\n        ClientAuthError.createUnexpectedCredentialTypeError();\n    }\n\n    this.setItem(StaticCacheKeys.TOKEN_KEYS + \".\" + this.clientId, JSON.stringify(tokenKeys));\n  };\n  /**\r\n   * Removes the given key from the token key map\r\n   * @param key\r\n   * @param type\r\n   */\n\n\n  BrowserCacheManager.prototype.removeTokenKey = function (key, type) {\n    this.logger.trace(\"BrowserCacheManager removeTokenKey called\");\n    var tokenKeys = this.getTokenKeys();\n\n    switch (type) {\n      case CredentialType.ID_TOKEN:\n        this.logger.infoPii(\"BrowserCacheManager: removeTokenKey - attempting to remove idToken with key: \" + key + \" from map\");\n        var idRemoval = tokenKeys.idToken.indexOf(key);\n\n        if (idRemoval > -1) {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - idToken removed from map\");\n          tokenKeys.idToken.splice(idRemoval, 1);\n        } else {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - idToken does not exist in map. Either it was previously removed or it was never added.\");\n        }\n\n        break;\n\n      case CredentialType.ACCESS_TOKEN:\n        this.logger.infoPii(\"BrowserCacheManager: removeTokenKey - attempting to remove accessToken with key: \" + key + \" from map\");\n        var accessRemoval = tokenKeys.accessToken.indexOf(key);\n\n        if (accessRemoval > -1) {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - accessToken removed from map\");\n          tokenKeys.accessToken.splice(accessRemoval, 1);\n        } else {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - accessToken does not exist in map. Either it was previously removed or it was never added.\");\n        }\n\n        break;\n\n      case CredentialType.REFRESH_TOKEN:\n        this.logger.infoPii(\"BrowserCacheManager: removeTokenKey - attempting to remove refreshToken with key: \" + key + \" from map\");\n        var refreshRemoval = tokenKeys.refreshToken.indexOf(key);\n\n        if (refreshRemoval > -1) {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - refreshToken removed from map\");\n          tokenKeys.refreshToken.splice(refreshRemoval, 1);\n        } else {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - refreshToken does not exist in map. Either it was previously removed or it was never added.\");\n        }\n\n        break;\n\n      default:\n        this.logger.error(\"BrowserCacheManager:removeTokenKey - CredentialType provided invalid. CredentialType: \" + type);\n        ClientAuthError.createUnexpectedCredentialTypeError();\n    }\n\n    this.setItem(StaticCacheKeys.TOKEN_KEYS + \".\" + this.clientId, JSON.stringify(tokenKeys));\n  };\n  /**\r\n   * generates idToken entity from a string\r\n   * @param idTokenKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getIdTokenCredential = function (idTokenKey) {\n    var value = this.getItem(idTokenKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n      this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n      return null;\n    }\n\n    var parsedIdToken = this.validateAndParseJson(value);\n\n    if (!parsedIdToken || !IdTokenEntity.isIdTokenEntity(parsedIdToken)) {\n      this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n      this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: cache hit\");\n    return CacheManager.toObject(new IdTokenEntity(), parsedIdToken);\n  };\n  /**\r\n   * set IdToken credential to the platform cache\r\n   * @param idToken\r\n   */\n\n\n  BrowserCacheManager.prototype.setIdTokenCredential = function (idToken) {\n    this.logger.trace(\"BrowserCacheManager.setIdTokenCredential called\");\n    var idTokenKey = idToken.generateCredentialKey();\n    this.setItem(idTokenKey, JSON.stringify(idToken));\n    this.addTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n  };\n  /**\r\n   * generates accessToken entity from a string\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.getAccessTokenCredential = function (accessTokenKey) {\n    var value = this.getItem(accessTokenKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n      this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n      return null;\n    }\n\n    var parsedAccessToken = this.validateAndParseJson(value);\n\n    if (!parsedAccessToken || !AccessTokenEntity.isAccessTokenEntity(parsedAccessToken)) {\n      this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n      this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: cache hit\");\n    return CacheManager.toObject(new AccessTokenEntity(), parsedAccessToken);\n  };\n  /**\r\n   * set accessToken credential to the platform cache\r\n   * @param accessToken\r\n   */\n\n\n  BrowserCacheManager.prototype.setAccessTokenCredential = function (accessToken) {\n    this.logger.trace(\"BrowserCacheManager.setAccessTokenCredential called\");\n    var accessTokenKey = accessToken.generateCredentialKey();\n    this.setItem(accessTokenKey, JSON.stringify(accessToken));\n    this.addTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n  };\n  /**\r\n   * generates refreshToken entity from a string\r\n   * @param refreshTokenKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getRefreshTokenCredential = function (refreshTokenKey) {\n    var value = this.getItem(refreshTokenKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n      this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n      return null;\n    }\n\n    var parsedRefreshToken = this.validateAndParseJson(value);\n\n    if (!parsedRefreshToken || !RefreshTokenEntity.isRefreshTokenEntity(parsedRefreshToken)) {\n      this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n      this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: cache hit\");\n    return CacheManager.toObject(new RefreshTokenEntity(), parsedRefreshToken);\n  };\n  /**\r\n   * set refreshToken credential to the platform cache\r\n   * @param refreshToken\r\n   */\n\n\n  BrowserCacheManager.prototype.setRefreshTokenCredential = function (refreshToken) {\n    this.logger.trace(\"BrowserCacheManager.setRefreshTokenCredential called\");\n    var refreshTokenKey = refreshToken.generateCredentialKey();\n    this.setItem(refreshTokenKey, JSON.stringify(refreshToken));\n    this.addTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n  };\n  /**\r\n   * fetch appMetadata entity from the platform cache\r\n   * @param appMetadataKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getAppMetadata = function (appMetadataKey) {\n    var value = this.getItem(appMetadataKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n      return null;\n    }\n\n    var parsedMetadata = this.validateAndParseJson(value);\n\n    if (!parsedMetadata || !AppMetadataEntity.isAppMetadataEntity(appMetadataKey, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getAppMetadata: cache hit\");\n    return CacheManager.toObject(new AppMetadataEntity(), parsedMetadata);\n  };\n  /**\r\n   * set appMetadata entity to the platform cache\r\n   * @param appMetadata\r\n   */\n\n\n  BrowserCacheManager.prototype.setAppMetadata = function (appMetadata) {\n    this.logger.trace(\"BrowserCacheManager.setAppMetadata called\");\n    var appMetadataKey = appMetadata.generateAppMetadataKey();\n    this.setItem(appMetadataKey, JSON.stringify(appMetadata));\n  };\n  /**\r\n   * fetch server telemetry entity from the platform cache\r\n   * @param serverTelemetryKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getServerTelemetry = function (serverTelemetryKey) {\n    var value = this.getItem(serverTelemetryKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n      return null;\n    }\n\n    var parsedMetadata = this.validateAndParseJson(value);\n\n    if (!parsedMetadata || !ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetryKey, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getServerTelemetry: cache hit\");\n    return CacheManager.toObject(new ServerTelemetryEntity(), parsedMetadata);\n  };\n  /**\r\n   * set server telemetry entity to the platform cache\r\n   * @param serverTelemetryKey\r\n   * @param serverTelemetry\r\n   */\n\n\n  BrowserCacheManager.prototype.setServerTelemetry = function (serverTelemetryKey, serverTelemetry) {\n    this.logger.trace(\"BrowserCacheManager.setServerTelemetry called\");\n    this.setItem(serverTelemetryKey, JSON.stringify(serverTelemetry));\n  };\n  /**\r\n   *\r\n   */\n\n\n  BrowserCacheManager.prototype.getAuthorityMetadata = function (key) {\n    var value = this.internalStorage.getItem(key);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: called, no cache hit\");\n      return null;\n    }\n\n    var parsedMetadata = this.validateAndParseJson(value);\n\n    if (parsedMetadata && AuthorityMetadataEntity.isAuthorityMetadataEntity(key, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: cache hit\");\n      return CacheManager.toObject(new AuthorityMetadataEntity(), parsedMetadata);\n    }\n\n    return null;\n  };\n  /**\r\n   *\r\n   */\n\n\n  BrowserCacheManager.prototype.getAuthorityMetadataKeys = function () {\n    var _this = this;\n\n    var allKeys = this.internalStorage.getKeys();\n    return allKeys.filter(function (key) {\n      return _this.isAuthorityMetadata(key);\n    });\n  };\n  /**\r\n   * Sets wrapper metadata in memory\r\n   * @param wrapperSKU\r\n   * @param wrapperVersion\r\n   */\n\n\n  BrowserCacheManager.prototype.setWrapperMetadata = function (wrapperSKU, wrapperVersion) {\n    this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_SKU, wrapperSKU);\n    this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_VER, wrapperVersion);\n  };\n  /**\r\n   * Returns wrapper metadata from in-memory storage\r\n   */\n\n\n  BrowserCacheManager.prototype.getWrapperMetadata = function () {\n    var sku = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_SKU) || Constants.EMPTY_STRING;\n    var version = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_VER) || Constants.EMPTY_STRING;\n    return [sku, version];\n  };\n  /**\r\n   *\r\n   * @param entity\r\n   */\n\n\n  BrowserCacheManager.prototype.setAuthorityMetadata = function (key, entity) {\n    this.logger.trace(\"BrowserCacheManager.setAuthorityMetadata called\");\n    this.internalStorage.setItem(key, JSON.stringify(entity));\n  };\n  /**\r\n   * Gets the active account\r\n   */\n\n\n  BrowserCacheManager.prototype.getActiveAccount = function () {\n    var activeAccountKeyFilters = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\n    var activeAccountValueFilters = this.getItem(activeAccountKeyFilters);\n\n    if (!activeAccountValueFilters) {\n      // if new active account cache type isn't found, it's an old version, so look for that instead\n      this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account filters cache schema found, looking for legacy schema\");\n      var activeAccountKeyLocal = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\n      var activeAccountValueLocal = this.getItem(activeAccountKeyLocal);\n\n      if (!activeAccountValueLocal) {\n        this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account found\");\n        return null;\n      }\n\n      var activeAccount = this.getAccountInfoByFilter({\n        localAccountId: activeAccountValueLocal\n      })[0] || null;\n\n      if (activeAccount) {\n        this.logger.trace(\"BrowserCacheManager.getActiveAccount: Legacy active account cache schema found\");\n        this.logger.trace(\"BrowserCacheManager.getActiveAccount: Adding active account filters cache schema\");\n        this.setActiveAccount(activeAccount);\n        return activeAccount;\n      }\n\n      return null;\n    }\n\n    var activeAccountValueObj = this.validateAndParseJson(activeAccountValueFilters);\n\n    if (activeAccountValueObj) {\n      this.logger.trace(\"BrowserCacheManager.getActiveAccount: Active account filters schema found\");\n      return this.getAccountInfoByFilter({\n        homeAccountId: activeAccountValueObj.homeAccountId,\n        localAccountId: activeAccountValueObj.localAccountId\n      })[0] || null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account found\");\n    return null;\n  };\n  /**\r\n   * Sets the active account's localAccountId in cache\r\n   * @param account\r\n   */\n\n\n  BrowserCacheManager.prototype.setActiveAccount = function (account) {\n    var activeAccountKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\n    var activeAccountKeyLocal = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\n\n    if (account) {\n      this.logger.verbose(\"setActiveAccount: Active account set\");\n      var activeAccountValue = {\n        homeAccountId: account.homeAccountId,\n        localAccountId: account.localAccountId\n      };\n      this.browserStorage.setItem(activeAccountKey, JSON.stringify(activeAccountValue));\n      this.browserStorage.setItem(activeAccountKeyLocal, account.localAccountId);\n    } else {\n      this.logger.verbose(\"setActiveAccount: No account passed, active account not set\");\n      this.browserStorage.removeItem(activeAccountKey);\n      this.browserStorage.removeItem(activeAccountKeyLocal);\n    }\n  };\n  /**\r\n   * Gets a list of accounts that match all of the filters provided\r\n   * @param account\r\n   */\n\n\n  BrowserCacheManager.prototype.getAccountInfoByFilter = function (accountFilter) {\n    var allAccounts = this.getAllAccounts();\n    this.logger.trace(\"BrowserCacheManager.getAccountInfoByFilter: total \" + allAccounts.length + \" accounts found\");\n    return allAccounts.filter(function (accountObj) {\n      if (accountFilter.username && accountFilter.username.toLowerCase() !== accountObj.username.toLowerCase()) {\n        return false;\n      }\n\n      if (accountFilter.homeAccountId && accountFilter.homeAccountId !== accountObj.homeAccountId) {\n        return false;\n      }\n\n      if (accountFilter.localAccountId && accountFilter.localAccountId !== accountObj.localAccountId) {\n        return false;\n      }\n\n      if (accountFilter.tenantId && accountFilter.tenantId !== accountObj.tenantId) {\n        return false;\n      }\n\n      if (accountFilter.environment && accountFilter.environment !== accountObj.environment) {\n        return false;\n      }\n\n      return true;\n    });\n  };\n  /**\r\n   * Checks the cache for accounts matching loginHint or SID\r\n   * @param loginHint\r\n   * @param sid\r\n   */\n\n\n  BrowserCacheManager.prototype.getAccountInfoByHints = function (loginHint, sid) {\n    var matchingAccounts = this.getAllAccounts().filter(function (accountInfo) {\n      if (sid) {\n        var accountSid = accountInfo.idTokenClaims && accountInfo.idTokenClaims[\"sid\"];\n        return sid === accountSid;\n      }\n\n      if (loginHint) {\n        return loginHint === accountInfo.username;\n      }\n\n      return false;\n    });\n\n    if (matchingAccounts.length === 1) {\n      return matchingAccounts[0];\n    } else if (matchingAccounts.length > 1) {\n      throw ClientAuthError.createMultipleMatchingAccountsInCacheError();\n    }\n\n    return null;\n  };\n  /**\r\n   * fetch throttling entity from the platform cache\r\n   * @param throttlingCacheKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getThrottlingCache = function (throttlingCacheKey) {\n    var value = this.getItem(throttlingCacheKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n      return null;\n    }\n\n    var parsedThrottlingCache = this.validateAndParseJson(value);\n\n    if (!parsedThrottlingCache || !ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, parsedThrottlingCache)) {\n      this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getThrottlingCache: cache hit\");\n    return CacheManager.toObject(new ThrottlingEntity(), parsedThrottlingCache);\n  };\n  /**\r\n   * set throttling entity to the platform cache\r\n   * @param throttlingCacheKey\r\n   * @param throttlingCache\r\n   */\n\n\n  BrowserCacheManager.prototype.setThrottlingCache = function (throttlingCacheKey, throttlingCache) {\n    this.logger.trace(\"BrowserCacheManager.setThrottlingCache called\");\n    this.setItem(throttlingCacheKey, JSON.stringify(throttlingCache));\n  };\n  /**\r\n   * Gets cache item with given key.\r\n   * Will retrieve from cookies if storeAuthStateInCookie is set to true.\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.getTemporaryCache = function (cacheKey, generateKey) {\n    var key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      var itemCookie = this.getItemCookie(key);\n\n      if (itemCookie) {\n        this.logger.trace(\"BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies\");\n        return itemCookie;\n      }\n    }\n\n    var value = this.temporaryCacheStorage.getItem(key);\n\n    if (!value) {\n      // If temp cache item not found in session/memory, check local storage for items set by old versions\n      if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {\n        var item = this.browserStorage.getItem(key);\n\n        if (item) {\n          this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage\");\n          return item;\n        }\n      }\n\n      this.logger.trace(\"BrowserCacheManager.getTemporaryCache: No cache item found in local storage\");\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item returned\");\n    return value;\n  };\n  /**\r\n   * Sets the cache item with the key and value given.\r\n   * Stores in cookie if storeAuthStateInCookie is set to true.\r\n   * This can cause cookie overflow if used incorrectly.\r\n   * @param key\r\n   * @param value\r\n   */\n\n\n  BrowserCacheManager.prototype.setTemporaryCache = function (cacheKey, value, generateKey) {\n    var key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n    this.temporaryCacheStorage.setItem(key, value);\n\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      this.logger.trace(\"BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie\");\n      this.setItemCookie(key, value);\n    }\n  };\n  /**\r\n   * Removes the cache item with the given key.\r\n   * Will also clear the cookie item if storeAuthStateInCookie is set to true.\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.removeItem = function (key) {\n    this.browserStorage.removeItem(key);\n    this.temporaryCacheStorage.removeItem(key);\n\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      this.logger.trace(\"BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie\");\n      this.clearItemCookie(key);\n    }\n  };\n  /**\r\n   * Checks whether key is in cache.\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.containsKey = function (key) {\n    return this.browserStorage.containsKey(key) || this.temporaryCacheStorage.containsKey(key);\n  };\n  /**\r\n   * Gets all keys in window.\r\n   */\n\n\n  BrowserCacheManager.prototype.getKeys = function () {\n    return __spread(this.browserStorage.getKeys(), this.temporaryCacheStorage.getKeys());\n  };\n  /**\r\n   * Clears all cache entries created by MSAL.\r\n   */\n\n\n  BrowserCacheManager.prototype.clear = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // Removes all accounts and their credentials\n            return [4\n            /*yield*/\n            , this.removeAllAccounts()];\n\n          case 1:\n            // Removes all accounts and their credentials\n            _a.sent();\n\n            this.removeAppMetadata(); // Removes all remaining MSAL cache items\n\n            this.getKeys().forEach(function (cacheKey) {\n              // Check if key contains msal prefix; For now, we are clearing all the cache items created by MSAL.js\n              if ((_this.browserStorage.containsKey(cacheKey) || _this.temporaryCacheStorage.containsKey(cacheKey)) && (cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 || cacheKey.indexOf(_this.clientId) !== -1)) {\n                _this.removeItem(cacheKey);\n              }\n            });\n            this.internalStorage.clear();\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Clears all access tokes that have claims prior to saving the current one\r\n   * @param credential\r\n   * @returns\r\n   */\n\n\n  BrowserCacheManager.prototype.clearTokensAndKeysWithClaims = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var tokenKeys, removedAccessTokens;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.trace(\"BrowserCacheManager.clearTokensAndKeysWithClaims called\");\n            tokenKeys = this.getTokenKeys();\n            removedAccessTokens = [];\n            tokenKeys.accessToken.forEach(function (key) {\n              // if the access token has claims in its key, remove the token key and the token\n              var credential = _this.getAccessTokenCredential(key);\n\n              if ((credential === null || credential === void 0 ? void 0 : credential.requestedClaimsHash) && key.includes(credential.requestedClaimsHash.toLowerCase())) {\n                removedAccessTokens.push(_this.removeAccessToken(key));\n              }\n            });\n            return [4\n            /*yield*/\n            , Promise.all(removedAccessTokens)];\n\n          case 1:\n            _a.sent(); // warn if any access tokens are removed\n\n\n            if (removedAccessTokens.length > 0) {\n              this.logger.warning(removedAccessTokens.length + \" access tokens with claims in the cache keys have been removed from the cache.\");\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Add value to cookies\r\n   * @param cookieName\r\n   * @param cookieValue\r\n   * @param expires\r\n   */\n\n\n  BrowserCacheManager.prototype.setItemCookie = function (cookieName, cookieValue, expires) {\n    var cookieStr = encodeURIComponent(cookieName) + \"=\" + encodeURIComponent(cookieValue) + \";path=/;SameSite=Lax;\";\n\n    if (expires) {\n      var expireTime = this.getCookieExpirationTime(expires);\n      cookieStr += \"expires=\" + expireTime + \";\";\n    }\n\n    if (this.cacheConfig.secureCookies) {\n      cookieStr += \"Secure;\";\n    }\n\n    document.cookie = cookieStr;\n  };\n  /**\r\n   * Get one item by key from cookies\r\n   * @param cookieName\r\n   */\n\n\n  BrowserCacheManager.prototype.getItemCookie = function (cookieName) {\n    var name = encodeURIComponent(cookieName) + \"=\";\n    var cookieList = document.cookie.split(\";\");\n\n    for (var i = 0; i < cookieList.length; i++) {\n      var cookie = cookieList[i];\n\n      while (cookie.charAt(0) === \" \") {\n        cookie = cookie.substring(1);\n      }\n\n      if (cookie.indexOf(name) === 0) {\n        return decodeURIComponent(cookie.substring(name.length, cookie.length));\n      }\n    }\n\n    return Constants.EMPTY_STRING;\n  };\n  /**\r\n   * Clear all msal-related cookies currently set in the browser. Should only be used to clear temporary cache items.\r\n   */\n\n\n  BrowserCacheManager.prototype.clearMsalCookies = function () {\n    var _this = this;\n\n    var cookiePrefix = Constants.CACHE_PREFIX + \".\" + this.clientId;\n    var cookieList = document.cookie.split(\";\");\n    cookieList.forEach(function (cookie) {\n      while (cookie.charAt(0) === \" \") {\n        // eslint-disable-next-line no-param-reassign\n        cookie = cookie.substring(1);\n      }\n\n      if (cookie.indexOf(cookiePrefix) === 0) {\n        var cookieKey = cookie.split(\"=\")[0];\n\n        _this.clearItemCookie(cookieKey);\n      }\n    });\n  };\n  /**\r\n   * Clear an item in the cookies by key\r\n   * @param cookieName\r\n   */\n\n\n  BrowserCacheManager.prototype.clearItemCookie = function (cookieName) {\n    this.setItemCookie(cookieName, Constants.EMPTY_STRING, -1);\n  };\n  /**\r\n   * Get cookie expiration time\r\n   * @param cookieLifeDays\r\n   */\n\n\n  BrowserCacheManager.prototype.getCookieExpirationTime = function (cookieLifeDays) {\n    var today = new Date();\n    var expr = new Date(today.getTime() + cookieLifeDays * this.COOKIE_LIFE_MULTIPLIER);\n    return expr.toUTCString();\n  };\n  /**\r\n   * Gets the cache object referenced by the browser\r\n   */\n\n\n  BrowserCacheManager.prototype.getCache = function () {\n    return this.browserStorage;\n  };\n  /**\r\n   * interface compat, we cannot overwrite browser cache; Functionality is supported by individual entities in browser\r\n   */\n\n\n  BrowserCacheManager.prototype.setCache = function () {// sets nothing\n  };\n  /**\r\n   * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\r\n   * @param key\r\n   * @param addInstanceId\r\n   */\n\n\n  BrowserCacheManager.prototype.generateCacheKey = function (key) {\n    var generatedKey = this.validateAndParseJson(key);\n\n    if (!generatedKey) {\n      if (StringUtils.startsWith(key, Constants.CACHE_PREFIX) || StringUtils.startsWith(key, PersistentCacheKeys.ADAL_ID_TOKEN)) {\n        return key;\n      }\n\n      return Constants.CACHE_PREFIX + \".\" + this.clientId + \".\" + key;\n    }\n\n    return JSON.stringify(key);\n  };\n  /**\r\n   * Create authorityKey to cache authority\r\n   * @param state\r\n   */\n\n\n  BrowserCacheManager.prototype.generateAuthorityKey = function (stateString) {\n    var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;\n    return this.generateCacheKey(TemporaryCacheKeys.AUTHORITY + \".\" + stateId);\n  };\n  /**\r\n   * Create Nonce key to cache nonce\r\n   * @param state\r\n   */\n\n\n  BrowserCacheManager.prototype.generateNonceKey = function (stateString) {\n    var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;\n    return this.generateCacheKey(TemporaryCacheKeys.NONCE_IDTOKEN + \".\" + stateId);\n  };\n  /**\r\n   * Creates full cache key for the request state\r\n   * @param stateString State string for the request\r\n   */\n\n\n  BrowserCacheManager.prototype.generateStateKey = function (stateString) {\n    // Use the library state id to key temp storage for uniqueness for multiple concurrent requests\n    var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;\n    return this.generateCacheKey(TemporaryCacheKeys.REQUEST_STATE + \".\" + stateId);\n  };\n  /**\r\n   * Gets the cached authority based on the cached state. Returns empty if no cached state found.\r\n   */\n\n\n  BrowserCacheManager.prototype.getCachedAuthority = function (cachedState) {\n    var stateCacheKey = this.generateStateKey(cachedState);\n    var state = this.getTemporaryCache(stateCacheKey);\n\n    if (!state) {\n      return null;\n    }\n\n    var authorityCacheKey = this.generateAuthorityKey(state);\n    return this.getTemporaryCache(authorityCacheKey);\n  };\n  /**\r\n   * Updates account, authority, and state in cache\r\n   * @param serverAuthenticationRequest\r\n   * @param account\r\n   */\n\n\n  BrowserCacheManager.prototype.updateCacheEntries = function (state, nonce, authorityInstance, loginHint, account) {\n    this.logger.trace(\"BrowserCacheManager.updateCacheEntries called\"); // Cache the request state\n\n    var stateCacheKey = this.generateStateKey(state);\n    this.setTemporaryCache(stateCacheKey, state, false); // Cache the nonce\n\n    var nonceCacheKey = this.generateNonceKey(state);\n    this.setTemporaryCache(nonceCacheKey, nonce, false); // Cache authorityKey\n\n    var authorityCacheKey = this.generateAuthorityKey(state);\n    this.setTemporaryCache(authorityCacheKey, authorityInstance, false);\n\n    if (account) {\n      var ccsCredential = {\n        credential: account.homeAccountId,\n        type: CcsCredentialType.HOME_ACCOUNT_ID\n      };\n      this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\n    } else if (!StringUtils.isEmpty(loginHint)) {\n      var ccsCredential = {\n        credential: loginHint,\n        type: CcsCredentialType.UPN\n      };\n      this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\n    }\n  };\n  /**\r\n   * Reset all temporary cache items\r\n   * @param state\r\n   */\n\n\n  BrowserCacheManager.prototype.resetRequestCache = function (state) {\n    var _this = this;\n\n    this.logger.trace(\"BrowserCacheManager.resetRequestCache called\"); // check state and remove associated cache items\n\n    if (!StringUtils.isEmpty(state)) {\n      this.getKeys().forEach(function (key) {\n        if (key.indexOf(state) !== -1) {\n          _this.removeItem(key);\n        }\n      });\n    } // delete generic interactive request parameters\n\n\n    if (state) {\n      this.removeItem(this.generateStateKey(state));\n      this.removeItem(this.generateNonceKey(state));\n      this.removeItem(this.generateAuthorityKey(state));\n    }\n\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.URL_HASH));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CORRELATION_ID));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CCS_CREDENTIAL));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST));\n    this.setInteractionInProgress(false);\n  };\n  /**\r\n   * Removes temporary cache for the provided state\r\n   * @param stateString\r\n   */\n\n\n  BrowserCacheManager.prototype.cleanRequestByState = function (stateString) {\n    this.logger.trace(\"BrowserCacheManager.cleanRequestByState called\"); // Interaction is completed - remove interaction status.\n\n    if (stateString) {\n      var stateKey = this.generateStateKey(stateString);\n      var cachedState = this.temporaryCacheStorage.getItem(stateKey);\n      this.logger.infoPii(\"BrowserCacheManager.cleanRequestByState: Removing temporary cache items for state: \" + cachedState);\n      this.resetRequestCache(cachedState || Constants.EMPTY_STRING);\n    }\n\n    this.clearMsalCookies();\n  };\n  /**\r\n   * Looks in temporary cache for any state values with the provided interactionType and removes all temporary cache items for that state\r\n   * Used in scenarios where temp cache needs to be cleaned but state is not known, such as clicking browser back button.\r\n   * @param interactionType\r\n   */\n\n\n  BrowserCacheManager.prototype.cleanRequestByInteractionType = function (interactionType) {\n    var _this = this;\n\n    this.logger.trace(\"BrowserCacheManager.cleanRequestByInteractionType called\"); // Loop through all keys to find state key\n\n    this.getKeys().forEach(function (key) {\n      // If this key is not the state key, move on\n      if (key.indexOf(TemporaryCacheKeys.REQUEST_STATE) === -1) {\n        return;\n      } // Retrieve state value, return if not a valid value\n\n\n      var stateValue = _this.temporaryCacheStorage.getItem(key);\n\n      if (!stateValue) {\n        return;\n      } // Extract state and ensure it matches given InteractionType, then clean request cache\n\n\n      var parsedState = BrowserProtocolUtils.extractBrowserRequestState(_this.cryptoImpl, stateValue);\n\n      if (parsedState && parsedState.interactionType === interactionType) {\n        _this.logger.infoPii(\"BrowserCacheManager.cleanRequestByInteractionType: Removing temporary cache items for state: \" + stateValue);\n\n        _this.resetRequestCache(stateValue);\n      }\n    });\n    this.clearMsalCookies();\n    this.setInteractionInProgress(false);\n  };\n\n  BrowserCacheManager.prototype.cacheCodeRequest = function (authCodeRequest, browserCrypto) {\n    this.logger.trace(\"BrowserCacheManager.cacheCodeRequest called\");\n    var encodedValue = browserCrypto.base64Encode(JSON.stringify(authCodeRequest));\n    this.setTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, encodedValue, true);\n  };\n  /**\r\n   * Gets the token exchange parameters from the cache. Throws an error if nothing is found.\r\n   */\n\n\n  BrowserCacheManager.prototype.getCachedRequest = function (state, browserCrypto) {\n    this.logger.trace(\"BrowserCacheManager.getCachedRequest called\"); // Get token request from cache and parse as TokenExchangeParameters.\n\n    var encodedTokenRequest = this.getTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, true);\n\n    if (!encodedTokenRequest) {\n      throw BrowserAuthError.createNoTokenRequestCacheError();\n    }\n\n    var parsedRequest = this.validateAndParseJson(browserCrypto.base64Decode(encodedTokenRequest));\n\n    if (!parsedRequest) {\n      throw BrowserAuthError.createUnableToParseTokenRequestCacheError();\n    }\n\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS)); // Get cached authority and use if no authority is cached with request.\n\n    if (StringUtils.isEmpty(parsedRequest.authority)) {\n      var authorityCacheKey = this.generateAuthorityKey(state);\n      var cachedAuthority = this.getTemporaryCache(authorityCacheKey);\n\n      if (!cachedAuthority) {\n        throw BrowserAuthError.createNoCachedAuthorityError();\n      }\n\n      parsedRequest.authority = cachedAuthority;\n    }\n\n    return parsedRequest;\n  };\n  /**\r\n   * Gets cached native request for redirect flows\r\n   */\n\n\n  BrowserCacheManager.prototype.getCachedNativeRequest = function () {\n    this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest called\");\n    var cachedRequest = this.getTemporaryCache(TemporaryCacheKeys.NATIVE_REQUEST, true);\n\n    if (!cachedRequest) {\n      this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest: No cached native request found\");\n      return null;\n    }\n\n    var parsedRequest = this.validateAndParseJson(cachedRequest);\n\n    if (!parsedRequest) {\n      this.logger.error(\"BrowserCacheManager.getCachedNativeRequest: Unable to parse native request\");\n      return null;\n    }\n\n    return parsedRequest;\n  };\n\n  BrowserCacheManager.prototype.isInteractionInProgress = function (matchClientId) {\n    var clientId = this.getInteractionInProgress();\n\n    if (matchClientId) {\n      return clientId === this.clientId;\n    } else {\n      return !!clientId;\n    }\n  };\n\n  BrowserCacheManager.prototype.getInteractionInProgress = function () {\n    var key = Constants.CACHE_PREFIX + \".\" + TemporaryCacheKeys.INTERACTION_STATUS_KEY;\n    return this.getTemporaryCache(key, false);\n  };\n\n  BrowserCacheManager.prototype.setInteractionInProgress = function (inProgress) {\n    // Ensure we don't overwrite interaction in progress for a different clientId\n    var key = Constants.CACHE_PREFIX + \".\" + TemporaryCacheKeys.INTERACTION_STATUS_KEY;\n\n    if (inProgress) {\n      if (this.getInteractionInProgress()) {\n        throw BrowserAuthError.createInteractionInProgressError();\n      } else {\n        // No interaction is in progress\n        this.setTemporaryCache(key, this.clientId, false);\n      }\n    } else if (!inProgress && this.getInteractionInProgress() === this.clientId) {\n      this.removeItem(key);\n    }\n  };\n  /**\r\n   * Returns username retrieved from ADAL or MSAL v1 idToken\r\n   */\n\n\n  BrowserCacheManager.prototype.getLegacyLoginHint = function () {\n    // Only check for adal/msal token if no SSO params are being used\n    var adalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ADAL_ID_TOKEN);\n\n    if (adalIdTokenString) {\n      this.browserStorage.removeItem(PersistentCacheKeys.ADAL_ID_TOKEN);\n      this.logger.verbose(\"Cached ADAL id token retrieved.\");\n    } // Check for cached MSAL v1 id token\n\n\n    var msalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ID_TOKEN, true);\n\n    if (msalIdTokenString) {\n      this.removeItem(this.generateCacheKey(PersistentCacheKeys.ID_TOKEN));\n      this.logger.verbose(\"Cached MSAL.js v1 id token retrieved\");\n    }\n\n    var cachedIdTokenString = msalIdTokenString || adalIdTokenString;\n\n    if (cachedIdTokenString) {\n      var cachedIdToken = new IdToken(cachedIdTokenString, this.cryptoImpl);\n\n      if (cachedIdToken.claims && cachedIdToken.claims.preferred_username) {\n        this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 preferred_username as loginHint\");\n        return cachedIdToken.claims.preferred_username;\n      } else if (cachedIdToken.claims && cachedIdToken.claims.upn) {\n        this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 upn as loginHint\");\n        return cachedIdToken.claims.upn;\n      } else {\n        this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, however, no account hint claim found. Enable preferred_username or upn id token claim to get SSO.\");\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Updates a credential's cache key if the current cache key is outdated\r\n   */\n\n\n  BrowserCacheManager.prototype.updateCredentialCacheKey = function (currentCacheKey, credential) {\n    var updatedCacheKey = credential.generateCredentialKey();\n\n    if (currentCacheKey !== updatedCacheKey) {\n      var cacheItem = this.getItem(currentCacheKey);\n\n      if (cacheItem) {\n        this.removeItem(currentCacheKey);\n        this.setItem(updatedCacheKey, cacheItem);\n        this.logger.verbose(\"Updated an outdated \" + credential.credentialType + \" cache key\");\n        return updatedCacheKey;\n      } else {\n        this.logger.error(\"Attempted to update an outdated \" + credential.credentialType + \" cache key but no item matching the outdated key was found in storage\");\n      }\n    }\n\n    return currentCacheKey;\n  };\n  /**\r\n   * Returns application id as redirect context during AcquireTokenRedirect flow.\r\n   */\n\n\n  BrowserCacheManager.prototype.getRedirectRequestContext = function () {\n    return this.getTemporaryCache(TemporaryCacheKeys.REDIRECT_CONTEXT, true);\n  };\n  /**\r\n   * Sets application id as the redirect context during AcquireTokenRedirect flow.\r\n   * @param value\r\n   */\n\n\n  BrowserCacheManager.prototype.setRedirectRequestContext = function (value) {\n    this.setTemporaryCache(TemporaryCacheKeys.REDIRECT_CONTEXT, value, true);\n  };\n\n  return BrowserCacheManager;\n}(CacheManager);\n\nvar DEFAULT_BROWSER_CACHE_MANAGER = function (clientId, logger) {\n  var cacheOptions = {\n    cacheLocation: BrowserCacheLocation.MemoryStorage,\n    temporaryCacheLocation: BrowserCacheLocation.MemoryStorage,\n    storeAuthStateInCookie: false,\n    secureCookies: false,\n    cacheMigrationEnabled: false,\n    claimsBasedCachingEnabled: true\n  };\n  return new BrowserCacheManager(clientId, cacheOptions, DEFAULT_CRYPTO_IMPLEMENTATION, logger);\n};\n\nexport { BrowserCacheManager, DEFAULT_BROWSER_CACHE_MANAGER };","map":{"version":3,"names":["__extends","__awaiter","__generator","__spread","CredentialType","RefreshTokenEntity","CacheManager","AccessTokenEntity","IdTokenEntity","AccountEntity","ClientAuthError","AppMetadataEntity","ServerTelemetryEntity","AuthorityMetadataEntity","Constants","PersistentCacheKeys","ThrottlingEntity","StringUtils","ProtocolUtils","CcsCredentialType","IdToken","DEFAULT_CRYPTO_IMPLEMENTATION","BrowserAuthError","BrowserCacheLocation","StaticCacheKeys","InMemoryCacheKeys","TemporaryCacheKeys","BrowserStorage","MemoryStorage","BrowserProtocolUtils","BrowserCacheManager","_super","clientId","cacheConfig","cryptoImpl","logger","_this","call","COOKIE_LIFE_MULTIPLIER","internalStorage","browserStorage","setupBrowserStorage","cacheLocation","temporaryCacheStorage","setupTemporaryCacheStorage","temporaryCacheLocation","cacheMigrationEnabled","migrateCacheEntries","createKeyMaps","prototype","LocalStorage","SessionStorage","e","verbose","idTokenKey","CACHE_PREFIX","ID_TOKEN","clientInfoKey","CLIENT_INFO","errorKey","ERROR","errorDescKey","ERROR_DESC","idTokenValue","getItem","clientInfoValue","errorValue","errorDescValue","values","keysToMigrate","forEach","cacheKey","index","migrateCacheEntry","newKey","value","setTemporaryCache","trace","accountKeys","ACCOUNT_KEYS","tokenKeys","TOKEN_KEYS","allKeys","getKeys","key","isCredentialKey","credObj","validateAndParseJson","hasOwnProperty","isIdTokenEntity","tracePii","idTokenEntity","toObject","updateCredentialCacheKey","addTokenKey","ACCESS_TOKEN","ACCESS_TOKEN_WITH_AUTH_SCHEME","isAccessTokenEntity","accessTokenEntity","REFRESH_TOKEN","isRefreshTokenEntity","refreshTokenEntity","isAccountKey","accountObj","isAccountEntity","addAccountKeyToMap","jsonValue","parsedJson","JSON","parse","error","setItem","getAccount","accountKey","account","removeAccountKeyFromMap","parsedAccount","setAccount","generateAccountKey","stringify","getAccountKeys","indexOf","push","removalIndex","splice","removeAccount","_a","removeIdToken","removeTokenKey","removeAccessToken","removeRefreshToken","getTokenKeys","item","idToken","accessToken","refreshToken","type","info","createUnexpectedCredentialTypeError","infoPii","idRemoval","accessRemoval","refreshRemoval","getIdTokenCredential","parsedIdToken","setIdTokenCredential","generateCredentialKey","getAccessTokenCredential","accessTokenKey","parsedAccessToken","setAccessTokenCredential","getRefreshTokenCredential","refreshTokenKey","parsedRefreshToken","setRefreshTokenCredential","getAppMetadata","appMetadataKey","parsedMetadata","isAppMetadataEntity","setAppMetadata","appMetadata","generateAppMetadataKey","getServerTelemetry","serverTelemetryKey","isServerTelemetryEntity","setServerTelemetry","serverTelemetry","getAuthorityMetadata","isAuthorityMetadataEntity","getAuthorityMetadataKeys","filter","isAuthorityMetadata","setWrapperMetadata","wrapperSKU","wrapperVersion","WRAPPER_SKU","WRAPPER_VER","getWrapperMetadata","sku","EMPTY_STRING","version","setAuthorityMetadata","entity","getActiveAccount","activeAccountKeyFilters","generateCacheKey","ACTIVE_ACCOUNT_FILTERS","activeAccountValueFilters","activeAccountKeyLocal","ACTIVE_ACCOUNT","activeAccountValueLocal","activeAccount","getAccountInfoByFilter","localAccountId","setActiveAccount","activeAccountValueObj","homeAccountId","activeAccountKey","activeAccountValue","removeItem","accountFilter","allAccounts","getAllAccounts","length","username","toLowerCase","tenantId","environment","getAccountInfoByHints","loginHint","sid","matchingAccounts","accountInfo","accountSid","idTokenClaims","createMultipleMatchingAccountsInCacheError","getThrottlingCache","throttlingCacheKey","parsedThrottlingCache","isThrottlingEntity","setThrottlingCache","throttlingCache","getTemporaryCache","generateKey","storeAuthStateInCookie","itemCookie","getItemCookie","setItemCookie","clearItemCookie","containsKey","clear","label","removeAllAccounts","sent","removeAppMetadata","clearTokensAndKeysWithClaims","removedAccessTokens","credential","requestedClaimsHash","includes","Promise","all","warning","cookieName","cookieValue","expires","cookieStr","encodeURIComponent","expireTime","getCookieExpirationTime","secureCookies","document","cookie","name","cookieList","split","i","charAt","substring","decodeURIComponent","clearMsalCookies","cookiePrefix","cookieKey","cookieLifeDays","today","Date","expr","getTime","toUTCString","getCache","setCache","generatedKey","startsWith","ADAL_ID_TOKEN","generateAuthorityKey","stateString","stateId","parseRequestState","libraryState","id","AUTHORITY","generateNonceKey","NONCE_IDTOKEN","generateStateKey","REQUEST_STATE","getCachedAuthority","cachedState","stateCacheKey","state","authorityCacheKey","updateCacheEntries","nonce","authorityInstance","nonceCacheKey","ccsCredential","HOME_ACCOUNT_ID","CCS_CREDENTIAL","isEmpty","UPN","resetRequestCache","REQUEST_PARAMS","ORIGIN_URI","URL_HASH","CORRELATION_ID","NATIVE_REQUEST","setInteractionInProgress","cleanRequestByState","stateKey","cleanRequestByInteractionType","interactionType","stateValue","parsedState","extractBrowserRequestState","cacheCodeRequest","authCodeRequest","browserCrypto","encodedValue","base64Encode","getCachedRequest","encodedTokenRequest","createNoTokenRequestCacheError","parsedRequest","base64Decode","createUnableToParseTokenRequestCacheError","authority","cachedAuthority","createNoCachedAuthorityError","getCachedNativeRequest","cachedRequest","isInteractionInProgress","matchClientId","getInteractionInProgress","INTERACTION_STATUS_KEY","inProgress","createInteractionInProgressError","getLegacyLoginHint","adalIdTokenString","msalIdTokenString","cachedIdTokenString","cachedIdToken","claims","preferred_username","upn","currentCacheKey","updatedCacheKey","cacheItem","credentialType","getRedirectRequestContext","REDIRECT_CONTEXT","setRedirectRequestContext","DEFAULT_BROWSER_CACHE_MANAGER","cacheOptions","claimsBasedCachingEnabled"],"sources":["F:/Bovis/Front/bovis-dev/node_modules/@azure/msal-browser/dist/cache/BrowserCacheManager.js"],"sourcesContent":["/*! @azure/msal-browser v2.38.3 2023-10-27 */\n'use strict';\nimport { __extends, __awaiter, __generator, __spread } from '../_virtual/_tslib.js';\nimport { CredentialType, RefreshTokenEntity, CacheManager, AccessTokenEntity, IdTokenEntity, AccountEntity, ClientAuthError, AppMetadataEntity, ServerTelemetryEntity, AuthorityMetadataEntity, Constants, PersistentCacheKeys, ThrottlingEntity, StringUtils, ProtocolUtils, CcsCredentialType, IdToken, DEFAULT_CRYPTO_IMPLEMENTATION } from '@azure/msal-common';\nimport { BrowserAuthError } from '../error/BrowserAuthError.js';\nimport { BrowserCacheLocation, StaticCacheKeys, InMemoryCacheKeys, TemporaryCacheKeys } from '../utils/BrowserConstants.js';\nimport { BrowserStorage } from './BrowserStorage.js';\nimport { MemoryStorage } from './MemoryStorage.js';\nimport { BrowserProtocolUtils } from '../utils/BrowserProtocolUtils.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * This class implements the cache storage interface for MSAL through browser local or session storage.\r\n * Cookies are only used if storeAuthStateInCookie is true, and are only used for\r\n * parameters such as state and nonce, generally.\r\n */\r\nvar BrowserCacheManager = /** @class */ (function (_super) {\r\n    __extends(BrowserCacheManager, _super);\r\n    function BrowserCacheManager(clientId, cacheConfig, cryptoImpl, logger) {\r\n        var _this = _super.call(this, clientId, cryptoImpl, logger) || this;\r\n        // Cookie life calculation (hours * minutes * seconds * ms)\r\n        _this.COOKIE_LIFE_MULTIPLIER = 24 * 60 * 60 * 1000;\r\n        _this.cacheConfig = cacheConfig;\r\n        _this.logger = logger;\r\n        _this.internalStorage = new MemoryStorage();\r\n        _this.browserStorage = _this.setupBrowserStorage(_this.cacheConfig.cacheLocation);\r\n        _this.temporaryCacheStorage = _this.setupTemporaryCacheStorage(_this.cacheConfig.temporaryCacheLocation, _this.cacheConfig.cacheLocation);\r\n        // Migrate cache entries from older versions of MSAL.\r\n        if (cacheConfig.cacheMigrationEnabled) {\r\n            _this.migrateCacheEntries();\r\n            _this.createKeyMaps();\r\n        }\r\n        return _this;\r\n    }\r\n    /**\r\n     * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured cacheLocation.\r\n     * @param cacheLocation\r\n     */\r\n    BrowserCacheManager.prototype.setupBrowserStorage = function (cacheLocation) {\r\n        switch (cacheLocation) {\r\n            case BrowserCacheLocation.LocalStorage:\r\n            case BrowserCacheLocation.SessionStorage:\r\n                try {\r\n                    return new BrowserStorage(cacheLocation);\r\n                }\r\n                catch (e) {\r\n                    this.logger.verbose(e);\r\n                    break;\r\n                }\r\n        }\r\n        this.cacheConfig.cacheLocation = BrowserCacheLocation.MemoryStorage;\r\n        return new MemoryStorage();\r\n    };\r\n    /**\r\n     * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured temporaryCacheLocation.\r\n     * @param temporaryCacheLocation\r\n     * @param cacheLocation\r\n     */\r\n    BrowserCacheManager.prototype.setupTemporaryCacheStorage = function (temporaryCacheLocation, cacheLocation) {\r\n        switch (cacheLocation) {\r\n            case BrowserCacheLocation.LocalStorage:\r\n            case BrowserCacheLocation.SessionStorage:\r\n                try {\r\n                    /*\r\n                     * When users do not explicitly choose their own temporaryCacheLocation,\r\n                     * temporary cache items will always be stored in session storage to mitigate problems caused by multiple tabs\r\n                     */\r\n                    return new BrowserStorage(temporaryCacheLocation || BrowserCacheLocation.SessionStorage);\r\n                }\r\n                catch (e) {\r\n                    this.logger.verbose(e);\r\n                    return this.internalStorage;\r\n                }\r\n            case BrowserCacheLocation.MemoryStorage:\r\n            default:\r\n                return this.internalStorage;\r\n        }\r\n    };\r\n    /**\r\n     * Migrate all old cache entries to new schema. No rollback supported.\r\n     * @param storeAuthStateInCookie\r\n     */\r\n    BrowserCacheManager.prototype.migrateCacheEntries = function () {\r\n        var _this = this;\r\n        var idTokenKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.ID_TOKEN;\r\n        var clientInfoKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.CLIENT_INFO;\r\n        var errorKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.ERROR;\r\n        var errorDescKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.ERROR_DESC;\r\n        var idTokenValue = this.browserStorage.getItem(idTokenKey);\r\n        var clientInfoValue = this.browserStorage.getItem(clientInfoKey);\r\n        var errorValue = this.browserStorage.getItem(errorKey);\r\n        var errorDescValue = this.browserStorage.getItem(errorDescKey);\r\n        var values = [idTokenValue, clientInfoValue, errorValue, errorDescValue];\r\n        var keysToMigrate = [PersistentCacheKeys.ID_TOKEN, PersistentCacheKeys.CLIENT_INFO, PersistentCacheKeys.ERROR, PersistentCacheKeys.ERROR_DESC];\r\n        keysToMigrate.forEach(function (cacheKey, index) { return _this.migrateCacheEntry(cacheKey, values[index]); });\r\n    };\r\n    /**\r\n     * Utility function to help with migration.\r\n     * @param newKey\r\n     * @param value\r\n     * @param storeAuthStateInCookie\r\n     */\r\n    BrowserCacheManager.prototype.migrateCacheEntry = function (newKey, value) {\r\n        if (value) {\r\n            this.setTemporaryCache(newKey, value, true);\r\n        }\r\n    };\r\n    /**\r\n     * Searches all cache entries for MSAL accounts and creates the account key map\r\n     * This is used to migrate users from older versions of MSAL which did not create the map.\r\n     * @returns\r\n     */\r\n    BrowserCacheManager.prototype.createKeyMaps = function () {\r\n        var _this = this;\r\n        this.logger.trace(\"BrowserCacheManager - createKeyMaps called.\");\r\n        var accountKeys = this.getItem(StaticCacheKeys.ACCOUNT_KEYS);\r\n        var tokenKeys = this.getItem(StaticCacheKeys.TOKEN_KEYS + \".\" + this.clientId);\r\n        if (accountKeys && tokenKeys) {\r\n            this.logger.verbose(\"BrowserCacheManager:createKeyMaps - account and token key maps already exist, skipping migration.\");\r\n            // Key maps already exist, no need to iterate through cache\r\n            return;\r\n        }\r\n        var allKeys = this.browserStorage.getKeys();\r\n        allKeys.forEach(function (key) {\r\n            if (_this.isCredentialKey(key)) {\r\n                // Get item, parse, validate and write key to map\r\n                var value = _this.getItem(key);\r\n                if (value) {\r\n                    var credObj = _this.validateAndParseJson(value);\r\n                    if (credObj && credObj.hasOwnProperty(\"credentialType\")) {\r\n                        switch (credObj[\"credentialType\"]) {\r\n                            case CredentialType.ID_TOKEN:\r\n                                if (IdTokenEntity.isIdTokenEntity(credObj)) {\r\n                                    _this.logger.trace(\"BrowserCacheManager:createKeyMaps - idToken found, saving key to token key map\");\r\n                                    _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - idToken with key: \" + key + \" found, saving key to token key map\");\r\n                                    var idTokenEntity = CacheManager.toObject(new IdTokenEntity(), credObj);\r\n                                    var newKey = _this.updateCredentialCacheKey(key, idTokenEntity);\r\n                                    _this.addTokenKey(newKey, CredentialType.ID_TOKEN);\r\n                                    return;\r\n                                }\r\n                                else {\r\n                                    _this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching idToken schema with value containing idToken credentialType field but value failed IdTokenEntity validation, skipping.\");\r\n                                    _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - failed idToken validation on key: \" + key);\r\n                                }\r\n                                break;\r\n                            case CredentialType.ACCESS_TOKEN:\r\n                            case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\r\n                                if (AccessTokenEntity.isAccessTokenEntity(credObj)) {\r\n                                    _this.logger.trace(\"BrowserCacheManager:createKeyMaps - accessToken found, saving key to token key map\");\r\n                                    _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - accessToken with key: \" + key + \" found, saving key to token key map\");\r\n                                    var accessTokenEntity = CacheManager.toObject(new AccessTokenEntity(), credObj);\r\n                                    var newKey = _this.updateCredentialCacheKey(key, accessTokenEntity);\r\n                                    _this.addTokenKey(newKey, CredentialType.ACCESS_TOKEN);\r\n                                    return;\r\n                                }\r\n                                else {\r\n                                    _this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching accessToken schema with value containing accessToken credentialType field but value failed AccessTokenEntity validation, skipping.\");\r\n                                    _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - failed accessToken validation on key: \" + key);\r\n                                }\r\n                                break;\r\n                            case CredentialType.REFRESH_TOKEN:\r\n                                if (RefreshTokenEntity.isRefreshTokenEntity(credObj)) {\r\n                                    _this.logger.trace(\"BrowserCacheManager:createKeyMaps - refreshToken found, saving key to token key map\");\r\n                                    _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - refreshToken with key: \" + key + \" found, saving key to token key map\");\r\n                                    var refreshTokenEntity = CacheManager.toObject(new RefreshTokenEntity(), credObj);\r\n                                    var newKey = _this.updateCredentialCacheKey(key, refreshTokenEntity);\r\n                                    _this.addTokenKey(newKey, CredentialType.REFRESH_TOKEN);\r\n                                    return;\r\n                                }\r\n                                else {\r\n                                    _this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching refreshToken schema with value containing refreshToken credentialType field but value failed RefreshTokenEntity validation, skipping.\");\r\n                                    _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - failed refreshToken validation on key: \" + key);\r\n                                }\r\n                                break;\r\n                            // If credentialType isn't one of our predefined ones, it may not be an MSAL cache value. Ignore.\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (_this.isAccountKey(key)) {\r\n                var value = _this.getItem(key);\r\n                if (value) {\r\n                    var accountObj = _this.validateAndParseJson(value);\r\n                    if (accountObj && AccountEntity.isAccountEntity(accountObj)) {\r\n                        _this.logger.trace(\"BrowserCacheManager:createKeyMaps - account found, saving key to account key map\");\r\n                        _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - account with key: \" + key + \" found, saving key to account key map\");\r\n                        _this.addAccountKeyToMap(key);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Parses passed value as JSON object, JSON.parse() will throw an error.\r\n     * @param input\r\n     */\r\n    BrowserCacheManager.prototype.validateAndParseJson = function (jsonValue) {\r\n        try {\r\n            var parsedJson = JSON.parse(jsonValue);\r\n            /**\r\n             * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\r\n             * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\r\n             * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\r\n             *\r\n             */\r\n            return (parsedJson && typeof parsedJson === \"object\") ? parsedJson : null;\r\n        }\r\n        catch (error) {\r\n            return null;\r\n        }\r\n    };\r\n    /**\r\n     * fetches the entry from the browser storage based off the key\r\n     * @param key\r\n     */\r\n    BrowserCacheManager.prototype.getItem = function (key) {\r\n        return this.browserStorage.getItem(key);\r\n    };\r\n    /**\r\n     * sets the entry in the browser storage\r\n     * @param key\r\n     * @param value\r\n     */\r\n    BrowserCacheManager.prototype.setItem = function (key, value) {\r\n        this.browserStorage.setItem(key, value);\r\n    };\r\n    /**\r\n     * fetch the account entity from the platform cache\r\n     * @param accountKey\r\n     */\r\n    BrowserCacheManager.prototype.getAccount = function (accountKey) {\r\n        this.logger.trace(\"BrowserCacheManager.getAccount called\");\r\n        var account = this.getItem(accountKey);\r\n        if (!account) {\r\n            this.removeAccountKeyFromMap(accountKey);\r\n            return null;\r\n        }\r\n        var parsedAccount = this.validateAndParseJson(account);\r\n        if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {\r\n            this.removeAccountKeyFromMap(accountKey);\r\n            return null;\r\n        }\r\n        return CacheManager.toObject(new AccountEntity(), parsedAccount);\r\n    };\r\n    /**\r\n     * set account entity in the platform cache\r\n     * @param key\r\n     * @param value\r\n     */\r\n    BrowserCacheManager.prototype.setAccount = function (account) {\r\n        this.logger.trace(\"BrowserCacheManager.setAccount called\");\r\n        var key = account.generateAccountKey();\r\n        this.setItem(key, JSON.stringify(account));\r\n        this.addAccountKeyToMap(key);\r\n    };\r\n    /**\r\n     * Returns the array of account keys currently cached\r\n     * @returns\r\n     */\r\n    BrowserCacheManager.prototype.getAccountKeys = function () {\r\n        this.logger.trace(\"BrowserCacheManager.getAccountKeys called\");\r\n        var accountKeys = this.getItem(StaticCacheKeys.ACCOUNT_KEYS);\r\n        if (accountKeys) {\r\n            return JSON.parse(accountKeys);\r\n        }\r\n        this.logger.verbose(\"BrowserCacheManager.getAccountKeys - No account keys found\");\r\n        return [];\r\n    };\r\n    /**\r\n     * Add a new account to the key map\r\n     * @param key\r\n     */\r\n    BrowserCacheManager.prototype.addAccountKeyToMap = function (key) {\r\n        this.logger.trace(\"BrowserCacheManager.addAccountKeyToMap called\");\r\n        this.logger.tracePii(\"BrowserCacheManager.addAccountKeyToMap called with key: \" + key);\r\n        var accountKeys = this.getAccountKeys();\r\n        if (accountKeys.indexOf(key) === -1) {\r\n            // Only add key if it does not already exist in the map\r\n            accountKeys.push(key);\r\n            this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));\r\n            this.logger.verbose(\"BrowserCacheManager.addAccountKeyToMap account key added\");\r\n        }\r\n        else {\r\n            this.logger.verbose(\"BrowserCacheManager.addAccountKeyToMap account key already exists in map\");\r\n        }\r\n    };\r\n    /**\r\n     * Remove an account from the key map\r\n     * @param key\r\n     */\r\n    BrowserCacheManager.prototype.removeAccountKeyFromMap = function (key) {\r\n        this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap called\");\r\n        this.logger.tracePii(\"BrowserCacheManager.removeAccountKeyFromMap called with key: \" + key);\r\n        var accountKeys = this.getAccountKeys();\r\n        var removalIndex = accountKeys.indexOf(key);\r\n        if (removalIndex > -1) {\r\n            accountKeys.splice(removalIndex, 1);\r\n            this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));\r\n            this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap account key removed\");\r\n        }\r\n        else {\r\n            this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap key not found in existing map\");\r\n        }\r\n    };\r\n    /**\r\n     * Extends inherited removeAccount function to include removal of the account key from the map\r\n     * @param key\r\n     */\r\n    BrowserCacheManager.prototype.removeAccount = function (key) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                _super.prototype.removeAccount.call(this, key);\r\n                this.removeAccountKeyFromMap(key);\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Removes given idToken from the cache and from the key map\r\n     * @param key\r\n     */\r\n    BrowserCacheManager.prototype.removeIdToken = function (key) {\r\n        _super.prototype.removeIdToken.call(this, key);\r\n        this.removeTokenKey(key, CredentialType.ID_TOKEN);\r\n    };\r\n    /**\r\n     * Removes given accessToken from the cache and from the key map\r\n     * @param key\r\n     */\r\n    BrowserCacheManager.prototype.removeAccessToken = function (key) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                _super.prototype.removeAccessToken.call(this, key);\r\n                this.removeTokenKey(key, CredentialType.ACCESS_TOKEN);\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Removes given refreshToken from the cache and from the key map\r\n     * @param key\r\n     */\r\n    BrowserCacheManager.prototype.removeRefreshToken = function (key) {\r\n        _super.prototype.removeRefreshToken.call(this, key);\r\n        this.removeTokenKey(key, CredentialType.REFRESH_TOKEN);\r\n    };\r\n    /**\r\n     * Gets the keys for the cached tokens associated with this clientId\r\n     * @returns\r\n     */\r\n    BrowserCacheManager.prototype.getTokenKeys = function () {\r\n        this.logger.trace(\"BrowserCacheManager.getTokenKeys called\");\r\n        var item = this.getItem(StaticCacheKeys.TOKEN_KEYS + \".\" + this.clientId);\r\n        if (item) {\r\n            var tokenKeys = this.validateAndParseJson(item);\r\n            if (tokenKeys &&\r\n                tokenKeys.hasOwnProperty(\"idToken\") &&\r\n                tokenKeys.hasOwnProperty(\"accessToken\") &&\r\n                tokenKeys.hasOwnProperty(\"refreshToken\")) {\r\n                return tokenKeys;\r\n            }\r\n            else {\r\n                this.logger.error(\"BrowserCacheManager.getTokenKeys - Token keys found but in an unknown format. Returning empty key map.\");\r\n            }\r\n        }\r\n        else {\r\n            this.logger.verbose(\"BrowserCacheManager.getTokenKeys - No token keys found\");\r\n        }\r\n        return {\r\n            idToken: [],\r\n            accessToken: [],\r\n            refreshToken: []\r\n        };\r\n    };\r\n    /**\r\n     * Adds the given key to the token key map\r\n     * @param key\r\n     * @param type\r\n     */\r\n    BrowserCacheManager.prototype.addTokenKey = function (key, type) {\r\n        this.logger.trace(\"BrowserCacheManager addTokenKey called\");\r\n        var tokenKeys = this.getTokenKeys();\r\n        switch (type) {\r\n            case CredentialType.ID_TOKEN:\r\n                if (tokenKeys.idToken.indexOf(key) === -1) {\r\n                    this.logger.info(\"BrowserCacheManager: addTokenKey - idToken added to map\");\r\n                    tokenKeys.idToken.push(key);\r\n                }\r\n                break;\r\n            case CredentialType.ACCESS_TOKEN:\r\n                if (tokenKeys.accessToken.indexOf(key) === -1) {\r\n                    this.logger.info(\"BrowserCacheManager: addTokenKey - accessToken added to map\");\r\n                    tokenKeys.accessToken.push(key);\r\n                }\r\n                break;\r\n            case CredentialType.REFRESH_TOKEN:\r\n                if (tokenKeys.refreshToken.indexOf(key) === -1) {\r\n                    this.logger.info(\"BrowserCacheManager: addTokenKey - refreshToken added to map\");\r\n                    tokenKeys.refreshToken.push(key);\r\n                }\r\n                break;\r\n            default:\r\n                this.logger.error(\"BrowserCacheManager:addTokenKey - CredentialType provided invalid. CredentialType: \" + type);\r\n                ClientAuthError.createUnexpectedCredentialTypeError();\r\n        }\r\n        this.setItem(StaticCacheKeys.TOKEN_KEYS + \".\" + this.clientId, JSON.stringify(tokenKeys));\r\n    };\r\n    /**\r\n     * Removes the given key from the token key map\r\n     * @param key\r\n     * @param type\r\n     */\r\n    BrowserCacheManager.prototype.removeTokenKey = function (key, type) {\r\n        this.logger.trace(\"BrowserCacheManager removeTokenKey called\");\r\n        var tokenKeys = this.getTokenKeys();\r\n        switch (type) {\r\n            case CredentialType.ID_TOKEN:\r\n                this.logger.infoPii(\"BrowserCacheManager: removeTokenKey - attempting to remove idToken with key: \" + key + \" from map\");\r\n                var idRemoval = tokenKeys.idToken.indexOf(key);\r\n                if (idRemoval > -1) {\r\n                    this.logger.info(\"BrowserCacheManager: removeTokenKey - idToken removed from map\");\r\n                    tokenKeys.idToken.splice(idRemoval, 1);\r\n                }\r\n                else {\r\n                    this.logger.info(\"BrowserCacheManager: removeTokenKey - idToken does not exist in map. Either it was previously removed or it was never added.\");\r\n                }\r\n                break;\r\n            case CredentialType.ACCESS_TOKEN:\r\n                this.logger.infoPii(\"BrowserCacheManager: removeTokenKey - attempting to remove accessToken with key: \" + key + \" from map\");\r\n                var accessRemoval = tokenKeys.accessToken.indexOf(key);\r\n                if (accessRemoval > -1) {\r\n                    this.logger.info(\"BrowserCacheManager: removeTokenKey - accessToken removed from map\");\r\n                    tokenKeys.accessToken.splice(accessRemoval, 1);\r\n                }\r\n                else {\r\n                    this.logger.info(\"BrowserCacheManager: removeTokenKey - accessToken does not exist in map. Either it was previously removed or it was never added.\");\r\n                }\r\n                break;\r\n            case CredentialType.REFRESH_TOKEN:\r\n                this.logger.infoPii(\"BrowserCacheManager: removeTokenKey - attempting to remove refreshToken with key: \" + key + \" from map\");\r\n                var refreshRemoval = tokenKeys.refreshToken.indexOf(key);\r\n                if (refreshRemoval > -1) {\r\n                    this.logger.info(\"BrowserCacheManager: removeTokenKey - refreshToken removed from map\");\r\n                    tokenKeys.refreshToken.splice(refreshRemoval, 1);\r\n                }\r\n                else {\r\n                    this.logger.info(\"BrowserCacheManager: removeTokenKey - refreshToken does not exist in map. Either it was previously removed or it was never added.\");\r\n                }\r\n                break;\r\n            default:\r\n                this.logger.error(\"BrowserCacheManager:removeTokenKey - CredentialType provided invalid. CredentialType: \" + type);\r\n                ClientAuthError.createUnexpectedCredentialTypeError();\r\n        }\r\n        this.setItem(StaticCacheKeys.TOKEN_KEYS + \".\" + this.clientId, JSON.stringify(tokenKeys));\r\n    };\r\n    /**\r\n     * generates idToken entity from a string\r\n     * @param idTokenKey\r\n     */\r\n    BrowserCacheManager.prototype.getIdTokenCredential = function (idTokenKey) {\r\n        var value = this.getItem(idTokenKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\r\n            this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);\r\n            return null;\r\n        }\r\n        var parsedIdToken = this.validateAndParseJson(value);\r\n        if (!parsedIdToken || !IdTokenEntity.isIdTokenEntity(parsedIdToken)) {\r\n            this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\r\n            this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);\r\n            return null;\r\n        }\r\n        this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: cache hit\");\r\n        return CacheManager.toObject(new IdTokenEntity(), parsedIdToken);\r\n    };\r\n    /**\r\n     * set IdToken credential to the platform cache\r\n     * @param idToken\r\n     */\r\n    BrowserCacheManager.prototype.setIdTokenCredential = function (idToken) {\r\n        this.logger.trace(\"BrowserCacheManager.setIdTokenCredential called\");\r\n        var idTokenKey = idToken.generateCredentialKey();\r\n        this.setItem(idTokenKey, JSON.stringify(idToken));\r\n        this.addTokenKey(idTokenKey, CredentialType.ID_TOKEN);\r\n    };\r\n    /**\r\n     * generates accessToken entity from a string\r\n     * @param key\r\n     */\r\n    BrowserCacheManager.prototype.getAccessTokenCredential = function (accessTokenKey) {\r\n        var value = this.getItem(accessTokenKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\r\n            this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\r\n            return null;\r\n        }\r\n        var parsedAccessToken = this.validateAndParseJson(value);\r\n        if (!parsedAccessToken || !AccessTokenEntity.isAccessTokenEntity(parsedAccessToken)) {\r\n            this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\r\n            this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\r\n            return null;\r\n        }\r\n        this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: cache hit\");\r\n        return CacheManager.toObject(new AccessTokenEntity(), parsedAccessToken);\r\n    };\r\n    /**\r\n     * set accessToken credential to the platform cache\r\n     * @param accessToken\r\n     */\r\n    BrowserCacheManager.prototype.setAccessTokenCredential = function (accessToken) {\r\n        this.logger.trace(\"BrowserCacheManager.setAccessTokenCredential called\");\r\n        var accessTokenKey = accessToken.generateCredentialKey();\r\n        this.setItem(accessTokenKey, JSON.stringify(accessToken));\r\n        this.addTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\r\n    };\r\n    /**\r\n     * generates refreshToken entity from a string\r\n     * @param refreshTokenKey\r\n     */\r\n    BrowserCacheManager.prototype.getRefreshTokenCredential = function (refreshTokenKey) {\r\n        var value = this.getItem(refreshTokenKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\r\n            this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\r\n            return null;\r\n        }\r\n        var parsedRefreshToken = this.validateAndParseJson(value);\r\n        if (!parsedRefreshToken || !RefreshTokenEntity.isRefreshTokenEntity(parsedRefreshToken)) {\r\n            this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\r\n            this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\r\n            return null;\r\n        }\r\n        this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: cache hit\");\r\n        return CacheManager.toObject(new RefreshTokenEntity(), parsedRefreshToken);\r\n    };\r\n    /**\r\n     * set refreshToken credential to the platform cache\r\n     * @param refreshToken\r\n     */\r\n    BrowserCacheManager.prototype.setRefreshTokenCredential = function (refreshToken) {\r\n        this.logger.trace(\"BrowserCacheManager.setRefreshTokenCredential called\");\r\n        var refreshTokenKey = refreshToken.generateCredentialKey();\r\n        this.setItem(refreshTokenKey, JSON.stringify(refreshToken));\r\n        this.addTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\r\n    };\r\n    /**\r\n     * fetch appMetadata entity from the platform cache\r\n     * @param appMetadataKey\r\n     */\r\n    BrowserCacheManager.prototype.getAppMetadata = function (appMetadataKey) {\r\n        var value = this.getItem(appMetadataKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\r\n            return null;\r\n        }\r\n        var parsedMetadata = this.validateAndParseJson(value);\r\n        if (!parsedMetadata || !AppMetadataEntity.isAppMetadataEntity(appMetadataKey, parsedMetadata)) {\r\n            this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\r\n            return null;\r\n        }\r\n        this.logger.trace(\"BrowserCacheManager.getAppMetadata: cache hit\");\r\n        return CacheManager.toObject(new AppMetadataEntity(), parsedMetadata);\r\n    };\r\n    /**\r\n     * set appMetadata entity to the platform cache\r\n     * @param appMetadata\r\n     */\r\n    BrowserCacheManager.prototype.setAppMetadata = function (appMetadata) {\r\n        this.logger.trace(\"BrowserCacheManager.setAppMetadata called\");\r\n        var appMetadataKey = appMetadata.generateAppMetadataKey();\r\n        this.setItem(appMetadataKey, JSON.stringify(appMetadata));\r\n    };\r\n    /**\r\n     * fetch server telemetry entity from the platform cache\r\n     * @param serverTelemetryKey\r\n     */\r\n    BrowserCacheManager.prototype.getServerTelemetry = function (serverTelemetryKey) {\r\n        var value = this.getItem(serverTelemetryKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\r\n            return null;\r\n        }\r\n        var parsedMetadata = this.validateAndParseJson(value);\r\n        if (!parsedMetadata || !ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetryKey, parsedMetadata)) {\r\n            this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\r\n            return null;\r\n        }\r\n        this.logger.trace(\"BrowserCacheManager.getServerTelemetry: cache hit\");\r\n        return CacheManager.toObject(new ServerTelemetryEntity(), parsedMetadata);\r\n    };\r\n    /**\r\n     * set server telemetry entity to the platform cache\r\n     * @param serverTelemetryKey\r\n     * @param serverTelemetry\r\n     */\r\n    BrowserCacheManager.prototype.setServerTelemetry = function (serverTelemetryKey, serverTelemetry) {\r\n        this.logger.trace(\"BrowserCacheManager.setServerTelemetry called\");\r\n        this.setItem(serverTelemetryKey, JSON.stringify(serverTelemetry));\r\n    };\r\n    /**\r\n     *\r\n     */\r\n    BrowserCacheManager.prototype.getAuthorityMetadata = function (key) {\r\n        var value = this.internalStorage.getItem(key);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: called, no cache hit\");\r\n            return null;\r\n        }\r\n        var parsedMetadata = this.validateAndParseJson(value);\r\n        if (parsedMetadata && AuthorityMetadataEntity.isAuthorityMetadataEntity(key, parsedMetadata)) {\r\n            this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: cache hit\");\r\n            return CacheManager.toObject(new AuthorityMetadataEntity(), parsedMetadata);\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     *\r\n     */\r\n    BrowserCacheManager.prototype.getAuthorityMetadataKeys = function () {\r\n        var _this = this;\r\n        var allKeys = this.internalStorage.getKeys();\r\n        return allKeys.filter(function (key) {\r\n            return _this.isAuthorityMetadata(key);\r\n        });\r\n    };\r\n    /**\r\n     * Sets wrapper metadata in memory\r\n     * @param wrapperSKU\r\n     * @param wrapperVersion\r\n     */\r\n    BrowserCacheManager.prototype.setWrapperMetadata = function (wrapperSKU, wrapperVersion) {\r\n        this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_SKU, wrapperSKU);\r\n        this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_VER, wrapperVersion);\r\n    };\r\n    /**\r\n     * Returns wrapper metadata from in-memory storage\r\n     */\r\n    BrowserCacheManager.prototype.getWrapperMetadata = function () {\r\n        var sku = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_SKU) || Constants.EMPTY_STRING;\r\n        var version = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_VER) || Constants.EMPTY_STRING;\r\n        return [sku, version];\r\n    };\r\n    /**\r\n     *\r\n     * @param entity\r\n     */\r\n    BrowserCacheManager.prototype.setAuthorityMetadata = function (key, entity) {\r\n        this.logger.trace(\"BrowserCacheManager.setAuthorityMetadata called\");\r\n        this.internalStorage.setItem(key, JSON.stringify(entity));\r\n    };\r\n    /**\r\n     * Gets the active account\r\n     */\r\n    BrowserCacheManager.prototype.getActiveAccount = function () {\r\n        var activeAccountKeyFilters = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\r\n        var activeAccountValueFilters = this.getItem(activeAccountKeyFilters);\r\n        if (!activeAccountValueFilters) {\r\n            // if new active account cache type isn't found, it's an old version, so look for that instead\r\n            this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account filters cache schema found, looking for legacy schema\");\r\n            var activeAccountKeyLocal = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\r\n            var activeAccountValueLocal = this.getItem(activeAccountKeyLocal);\r\n            if (!activeAccountValueLocal) {\r\n                this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account found\");\r\n                return null;\r\n            }\r\n            var activeAccount = this.getAccountInfoByFilter({ localAccountId: activeAccountValueLocal })[0] || null;\r\n            if (activeAccount) {\r\n                this.logger.trace(\"BrowserCacheManager.getActiveAccount: Legacy active account cache schema found\");\r\n                this.logger.trace(\"BrowserCacheManager.getActiveAccount: Adding active account filters cache schema\");\r\n                this.setActiveAccount(activeAccount);\r\n                return activeAccount;\r\n            }\r\n            return null;\r\n        }\r\n        var activeAccountValueObj = this.validateAndParseJson(activeAccountValueFilters);\r\n        if (activeAccountValueObj) {\r\n            this.logger.trace(\"BrowserCacheManager.getActiveAccount: Active account filters schema found\");\r\n            return this.getAccountInfoByFilter({\r\n                homeAccountId: activeAccountValueObj.homeAccountId,\r\n                localAccountId: activeAccountValueObj.localAccountId\r\n            })[0] || null;\r\n        }\r\n        this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account found\");\r\n        return null;\r\n    };\r\n    /**\r\n     * Sets the active account's localAccountId in cache\r\n     * @param account\r\n     */\r\n    BrowserCacheManager.prototype.setActiveAccount = function (account) {\r\n        var activeAccountKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\r\n        var activeAccountKeyLocal = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\r\n        if (account) {\r\n            this.logger.verbose(\"setActiveAccount: Active account set\");\r\n            var activeAccountValue = {\r\n                homeAccountId: account.homeAccountId,\r\n                localAccountId: account.localAccountId\r\n            };\r\n            this.browserStorage.setItem(activeAccountKey, JSON.stringify(activeAccountValue));\r\n            this.browserStorage.setItem(activeAccountKeyLocal, account.localAccountId);\r\n        }\r\n        else {\r\n            this.logger.verbose(\"setActiveAccount: No account passed, active account not set\");\r\n            this.browserStorage.removeItem(activeAccountKey);\r\n            this.browserStorage.removeItem(activeAccountKeyLocal);\r\n        }\r\n    };\r\n    /**\r\n     * Gets a list of accounts that match all of the filters provided\r\n     * @param account\r\n     */\r\n    BrowserCacheManager.prototype.getAccountInfoByFilter = function (accountFilter) {\r\n        var allAccounts = this.getAllAccounts();\r\n        this.logger.trace(\"BrowserCacheManager.getAccountInfoByFilter: total \" + allAccounts.length + \" accounts found\");\r\n        return allAccounts.filter(function (accountObj) {\r\n            if (accountFilter.username && accountFilter.username.toLowerCase() !== accountObj.username.toLowerCase()) {\r\n                return false;\r\n            }\r\n            if (accountFilter.homeAccountId && accountFilter.homeAccountId !== accountObj.homeAccountId) {\r\n                return false;\r\n            }\r\n            if (accountFilter.localAccountId && accountFilter.localAccountId !== accountObj.localAccountId) {\r\n                return false;\r\n            }\r\n            if (accountFilter.tenantId && accountFilter.tenantId !== accountObj.tenantId) {\r\n                return false;\r\n            }\r\n            if (accountFilter.environment && accountFilter.environment !== accountObj.environment) {\r\n                return false;\r\n            }\r\n            return true;\r\n        });\r\n    };\r\n    /**\r\n     * Checks the cache for accounts matching loginHint or SID\r\n     * @param loginHint\r\n     * @param sid\r\n     */\r\n    BrowserCacheManager.prototype.getAccountInfoByHints = function (loginHint, sid) {\r\n        var matchingAccounts = this.getAllAccounts().filter(function (accountInfo) {\r\n            if (sid) {\r\n                var accountSid = accountInfo.idTokenClaims && accountInfo.idTokenClaims[\"sid\"];\r\n                return sid === accountSid;\r\n            }\r\n            if (loginHint) {\r\n                return loginHint === accountInfo.username;\r\n            }\r\n            return false;\r\n        });\r\n        if (matchingAccounts.length === 1) {\r\n            return matchingAccounts[0];\r\n        }\r\n        else if (matchingAccounts.length > 1) {\r\n            throw ClientAuthError.createMultipleMatchingAccountsInCacheError();\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * fetch throttling entity from the platform cache\r\n     * @param throttlingCacheKey\r\n     */\r\n    BrowserCacheManager.prototype.getThrottlingCache = function (throttlingCacheKey) {\r\n        var value = this.getItem(throttlingCacheKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\r\n            return null;\r\n        }\r\n        var parsedThrottlingCache = this.validateAndParseJson(value);\r\n        if (!parsedThrottlingCache || !ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, parsedThrottlingCache)) {\r\n            this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\r\n            return null;\r\n        }\r\n        this.logger.trace(\"BrowserCacheManager.getThrottlingCache: cache hit\");\r\n        return CacheManager.toObject(new ThrottlingEntity(), parsedThrottlingCache);\r\n    };\r\n    /**\r\n     * set throttling entity to the platform cache\r\n     * @param throttlingCacheKey\r\n     * @param throttlingCache\r\n     */\r\n    BrowserCacheManager.prototype.setThrottlingCache = function (throttlingCacheKey, throttlingCache) {\r\n        this.logger.trace(\"BrowserCacheManager.setThrottlingCache called\");\r\n        this.setItem(throttlingCacheKey, JSON.stringify(throttlingCache));\r\n    };\r\n    /**\r\n     * Gets cache item with given key.\r\n     * Will retrieve from cookies if storeAuthStateInCookie is set to true.\r\n     * @param key\r\n     */\r\n    BrowserCacheManager.prototype.getTemporaryCache = function (cacheKey, generateKey) {\r\n        var key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\r\n        if (this.cacheConfig.storeAuthStateInCookie) {\r\n            var itemCookie = this.getItemCookie(key);\r\n            if (itemCookie) {\r\n                this.logger.trace(\"BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies\");\r\n                return itemCookie;\r\n            }\r\n        }\r\n        var value = this.temporaryCacheStorage.getItem(key);\r\n        if (!value) {\r\n            // If temp cache item not found in session/memory, check local storage for items set by old versions\r\n            if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {\r\n                var item = this.browserStorage.getItem(key);\r\n                if (item) {\r\n                    this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage\");\r\n                    return item;\r\n                }\r\n            }\r\n            this.logger.trace(\"BrowserCacheManager.getTemporaryCache: No cache item found in local storage\");\r\n            return null;\r\n        }\r\n        this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item returned\");\r\n        return value;\r\n    };\r\n    /**\r\n     * Sets the cache item with the key and value given.\r\n     * Stores in cookie if storeAuthStateInCookie is set to true.\r\n     * This can cause cookie overflow if used incorrectly.\r\n     * @param key\r\n     * @param value\r\n     */\r\n    BrowserCacheManager.prototype.setTemporaryCache = function (cacheKey, value, generateKey) {\r\n        var key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\r\n        this.temporaryCacheStorage.setItem(key, value);\r\n        if (this.cacheConfig.storeAuthStateInCookie) {\r\n            this.logger.trace(\"BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie\");\r\n            this.setItemCookie(key, value);\r\n        }\r\n    };\r\n    /**\r\n     * Removes the cache item with the given key.\r\n     * Will also clear the cookie item if storeAuthStateInCookie is set to true.\r\n     * @param key\r\n     */\r\n    BrowserCacheManager.prototype.removeItem = function (key) {\r\n        this.browserStorage.removeItem(key);\r\n        this.temporaryCacheStorage.removeItem(key);\r\n        if (this.cacheConfig.storeAuthStateInCookie) {\r\n            this.logger.trace(\"BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie\");\r\n            this.clearItemCookie(key);\r\n        }\r\n    };\r\n    /**\r\n     * Checks whether key is in cache.\r\n     * @param key\r\n     */\r\n    BrowserCacheManager.prototype.containsKey = function (key) {\r\n        return this.browserStorage.containsKey(key) || this.temporaryCacheStorage.containsKey(key);\r\n    };\r\n    /**\r\n     * Gets all keys in window.\r\n     */\r\n    BrowserCacheManager.prototype.getKeys = function () {\r\n        return __spread(this.browserStorage.getKeys(), this.temporaryCacheStorage.getKeys());\r\n    };\r\n    /**\r\n     * Clears all cache entries created by MSAL.\r\n     */\r\n    BrowserCacheManager.prototype.clear = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: \r\n                    // Removes all accounts and their credentials\r\n                    return [4 /*yield*/, this.removeAllAccounts()];\r\n                    case 1:\r\n                        // Removes all accounts and their credentials\r\n                        _a.sent();\r\n                        this.removeAppMetadata();\r\n                        // Removes all remaining MSAL cache items\r\n                        this.getKeys().forEach(function (cacheKey) {\r\n                            // Check if key contains msal prefix; For now, we are clearing all the cache items created by MSAL.js\r\n                            if ((_this.browserStorage.containsKey(cacheKey) || _this.temporaryCacheStorage.containsKey(cacheKey)) && ((cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1) || (cacheKey.indexOf(_this.clientId) !== -1))) {\r\n                                _this.removeItem(cacheKey);\r\n                            }\r\n                        });\r\n                        this.internalStorage.clear();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Clears all access tokes that have claims prior to saving the current one\r\n     * @param credential\r\n     * @returns\r\n     */\r\n    BrowserCacheManager.prototype.clearTokensAndKeysWithClaims = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var tokenKeys, removedAccessTokens;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        this.logger.trace(\"BrowserCacheManager.clearTokensAndKeysWithClaims called\");\r\n                        tokenKeys = this.getTokenKeys();\r\n                        removedAccessTokens = [];\r\n                        tokenKeys.accessToken.forEach(function (key) {\r\n                            // if the access token has claims in its key, remove the token key and the token\r\n                            var credential = _this.getAccessTokenCredential(key);\r\n                            if ((credential === null || credential === void 0 ? void 0 : credential.requestedClaimsHash) && key.includes(credential.requestedClaimsHash.toLowerCase())) {\r\n                                removedAccessTokens.push(_this.removeAccessToken(key));\r\n                            }\r\n                        });\r\n                        return [4 /*yield*/, Promise.all(removedAccessTokens)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        // warn if any access tokens are removed\r\n                        if (removedAccessTokens.length > 0) {\r\n                            this.logger.warning(removedAccessTokens.length + \" access tokens with claims in the cache keys have been removed from the cache.\");\r\n                        }\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Add value to cookies\r\n     * @param cookieName\r\n     * @param cookieValue\r\n     * @param expires\r\n     */\r\n    BrowserCacheManager.prototype.setItemCookie = function (cookieName, cookieValue, expires) {\r\n        var cookieStr = encodeURIComponent(cookieName) + \"=\" + encodeURIComponent(cookieValue) + \";path=/;SameSite=Lax;\";\r\n        if (expires) {\r\n            var expireTime = this.getCookieExpirationTime(expires);\r\n            cookieStr += \"expires=\" + expireTime + \";\";\r\n        }\r\n        if (this.cacheConfig.secureCookies) {\r\n            cookieStr += \"Secure;\";\r\n        }\r\n        document.cookie = cookieStr;\r\n    };\r\n    /**\r\n     * Get one item by key from cookies\r\n     * @param cookieName\r\n     */\r\n    BrowserCacheManager.prototype.getItemCookie = function (cookieName) {\r\n        var name = encodeURIComponent(cookieName) + \"=\";\r\n        var cookieList = document.cookie.split(\";\");\r\n        for (var i = 0; i < cookieList.length; i++) {\r\n            var cookie = cookieList[i];\r\n            while (cookie.charAt(0) === \" \") {\r\n                cookie = cookie.substring(1);\r\n            }\r\n            if (cookie.indexOf(name) === 0) {\r\n                return decodeURIComponent(cookie.substring(name.length, cookie.length));\r\n            }\r\n        }\r\n        return Constants.EMPTY_STRING;\r\n    };\r\n    /**\r\n     * Clear all msal-related cookies currently set in the browser. Should only be used to clear temporary cache items.\r\n     */\r\n    BrowserCacheManager.prototype.clearMsalCookies = function () {\r\n        var _this = this;\r\n        var cookiePrefix = Constants.CACHE_PREFIX + \".\" + this.clientId;\r\n        var cookieList = document.cookie.split(\";\");\r\n        cookieList.forEach(function (cookie) {\r\n            while (cookie.charAt(0) === \" \") {\r\n                // eslint-disable-next-line no-param-reassign\r\n                cookie = cookie.substring(1);\r\n            }\r\n            if (cookie.indexOf(cookiePrefix) === 0) {\r\n                var cookieKey = cookie.split(\"=\")[0];\r\n                _this.clearItemCookie(cookieKey);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Clear an item in the cookies by key\r\n     * @param cookieName\r\n     */\r\n    BrowserCacheManager.prototype.clearItemCookie = function (cookieName) {\r\n        this.setItemCookie(cookieName, Constants.EMPTY_STRING, -1);\r\n    };\r\n    /**\r\n     * Get cookie expiration time\r\n     * @param cookieLifeDays\r\n     */\r\n    BrowserCacheManager.prototype.getCookieExpirationTime = function (cookieLifeDays) {\r\n        var today = new Date();\r\n        var expr = new Date(today.getTime() + cookieLifeDays * this.COOKIE_LIFE_MULTIPLIER);\r\n        return expr.toUTCString();\r\n    };\r\n    /**\r\n     * Gets the cache object referenced by the browser\r\n     */\r\n    BrowserCacheManager.prototype.getCache = function () {\r\n        return this.browserStorage;\r\n    };\r\n    /**\r\n     * interface compat, we cannot overwrite browser cache; Functionality is supported by individual entities in browser\r\n     */\r\n    BrowserCacheManager.prototype.setCache = function () {\r\n        // sets nothing\r\n    };\r\n    /**\r\n     * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\r\n     * @param key\r\n     * @param addInstanceId\r\n     */\r\n    BrowserCacheManager.prototype.generateCacheKey = function (key) {\r\n        var generatedKey = this.validateAndParseJson(key);\r\n        if (!generatedKey) {\r\n            if (StringUtils.startsWith(key, Constants.CACHE_PREFIX) || StringUtils.startsWith(key, PersistentCacheKeys.ADAL_ID_TOKEN)) {\r\n                return key;\r\n            }\r\n            return Constants.CACHE_PREFIX + \".\" + this.clientId + \".\" + key;\r\n        }\r\n        return JSON.stringify(key);\r\n    };\r\n    /**\r\n     * Create authorityKey to cache authority\r\n     * @param state\r\n     */\r\n    BrowserCacheManager.prototype.generateAuthorityKey = function (stateString) {\r\n        var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;\r\n        return this.generateCacheKey(TemporaryCacheKeys.AUTHORITY + \".\" + stateId);\r\n    };\r\n    /**\r\n     * Create Nonce key to cache nonce\r\n     * @param state\r\n     */\r\n    BrowserCacheManager.prototype.generateNonceKey = function (stateString) {\r\n        var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;\r\n        return this.generateCacheKey(TemporaryCacheKeys.NONCE_IDTOKEN + \".\" + stateId);\r\n    };\r\n    /**\r\n     * Creates full cache key for the request state\r\n     * @param stateString State string for the request\r\n     */\r\n    BrowserCacheManager.prototype.generateStateKey = function (stateString) {\r\n        // Use the library state id to key temp storage for uniqueness for multiple concurrent requests\r\n        var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;\r\n        return this.generateCacheKey(TemporaryCacheKeys.REQUEST_STATE + \".\" + stateId);\r\n    };\r\n    /**\r\n     * Gets the cached authority based on the cached state. Returns empty if no cached state found.\r\n     */\r\n    BrowserCacheManager.prototype.getCachedAuthority = function (cachedState) {\r\n        var stateCacheKey = this.generateStateKey(cachedState);\r\n        var state = this.getTemporaryCache(stateCacheKey);\r\n        if (!state) {\r\n            return null;\r\n        }\r\n        var authorityCacheKey = this.generateAuthorityKey(state);\r\n        return this.getTemporaryCache(authorityCacheKey);\r\n    };\r\n    /**\r\n     * Updates account, authority, and state in cache\r\n     * @param serverAuthenticationRequest\r\n     * @param account\r\n     */\r\n    BrowserCacheManager.prototype.updateCacheEntries = function (state, nonce, authorityInstance, loginHint, account) {\r\n        this.logger.trace(\"BrowserCacheManager.updateCacheEntries called\");\r\n        // Cache the request state\r\n        var stateCacheKey = this.generateStateKey(state);\r\n        this.setTemporaryCache(stateCacheKey, state, false);\r\n        // Cache the nonce\r\n        var nonceCacheKey = this.generateNonceKey(state);\r\n        this.setTemporaryCache(nonceCacheKey, nonce, false);\r\n        // Cache authorityKey\r\n        var authorityCacheKey = this.generateAuthorityKey(state);\r\n        this.setTemporaryCache(authorityCacheKey, authorityInstance, false);\r\n        if (account) {\r\n            var ccsCredential = {\r\n                credential: account.homeAccountId,\r\n                type: CcsCredentialType.HOME_ACCOUNT_ID\r\n            };\r\n            this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\r\n        }\r\n        else if (!StringUtils.isEmpty(loginHint)) {\r\n            var ccsCredential = {\r\n                credential: loginHint,\r\n                type: CcsCredentialType.UPN\r\n            };\r\n            this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\r\n        }\r\n    };\r\n    /**\r\n     * Reset all temporary cache items\r\n     * @param state\r\n     */\r\n    BrowserCacheManager.prototype.resetRequestCache = function (state) {\r\n        var _this = this;\r\n        this.logger.trace(\"BrowserCacheManager.resetRequestCache called\");\r\n        // check state and remove associated cache items\r\n        if (!StringUtils.isEmpty(state)) {\r\n            this.getKeys().forEach(function (key) {\r\n                if (key.indexOf(state) !== -1) {\r\n                    _this.removeItem(key);\r\n                }\r\n            });\r\n        }\r\n        // delete generic interactive request parameters\r\n        if (state) {\r\n            this.removeItem(this.generateStateKey(state));\r\n            this.removeItem(this.generateNonceKey(state));\r\n            this.removeItem(this.generateAuthorityKey(state));\r\n        }\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI));\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.URL_HASH));\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CORRELATION_ID));\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CCS_CREDENTIAL));\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST));\r\n        this.setInteractionInProgress(false);\r\n    };\r\n    /**\r\n     * Removes temporary cache for the provided state\r\n     * @param stateString\r\n     */\r\n    BrowserCacheManager.prototype.cleanRequestByState = function (stateString) {\r\n        this.logger.trace(\"BrowserCacheManager.cleanRequestByState called\");\r\n        // Interaction is completed - remove interaction status.\r\n        if (stateString) {\r\n            var stateKey = this.generateStateKey(stateString);\r\n            var cachedState = this.temporaryCacheStorage.getItem(stateKey);\r\n            this.logger.infoPii(\"BrowserCacheManager.cleanRequestByState: Removing temporary cache items for state: \" + cachedState);\r\n            this.resetRequestCache(cachedState || Constants.EMPTY_STRING);\r\n        }\r\n        this.clearMsalCookies();\r\n    };\r\n    /**\r\n     * Looks in temporary cache for any state values with the provided interactionType and removes all temporary cache items for that state\r\n     * Used in scenarios where temp cache needs to be cleaned but state is not known, such as clicking browser back button.\r\n     * @param interactionType\r\n     */\r\n    BrowserCacheManager.prototype.cleanRequestByInteractionType = function (interactionType) {\r\n        var _this = this;\r\n        this.logger.trace(\"BrowserCacheManager.cleanRequestByInteractionType called\");\r\n        // Loop through all keys to find state key\r\n        this.getKeys().forEach(function (key) {\r\n            // If this key is not the state key, move on\r\n            if (key.indexOf(TemporaryCacheKeys.REQUEST_STATE) === -1) {\r\n                return;\r\n            }\r\n            // Retrieve state value, return if not a valid value\r\n            var stateValue = _this.temporaryCacheStorage.getItem(key);\r\n            if (!stateValue) {\r\n                return;\r\n            }\r\n            // Extract state and ensure it matches given InteractionType, then clean request cache\r\n            var parsedState = BrowserProtocolUtils.extractBrowserRequestState(_this.cryptoImpl, stateValue);\r\n            if (parsedState && parsedState.interactionType === interactionType) {\r\n                _this.logger.infoPii(\"BrowserCacheManager.cleanRequestByInteractionType: Removing temporary cache items for state: \" + stateValue);\r\n                _this.resetRequestCache(stateValue);\r\n            }\r\n        });\r\n        this.clearMsalCookies();\r\n        this.setInteractionInProgress(false);\r\n    };\r\n    BrowserCacheManager.prototype.cacheCodeRequest = function (authCodeRequest, browserCrypto) {\r\n        this.logger.trace(\"BrowserCacheManager.cacheCodeRequest called\");\r\n        var encodedValue = browserCrypto.base64Encode(JSON.stringify(authCodeRequest));\r\n        this.setTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, encodedValue, true);\r\n    };\r\n    /**\r\n     * Gets the token exchange parameters from the cache. Throws an error if nothing is found.\r\n     */\r\n    BrowserCacheManager.prototype.getCachedRequest = function (state, browserCrypto) {\r\n        this.logger.trace(\"BrowserCacheManager.getCachedRequest called\");\r\n        // Get token request from cache and parse as TokenExchangeParameters.\r\n        var encodedTokenRequest = this.getTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, true);\r\n        if (!encodedTokenRequest) {\r\n            throw BrowserAuthError.createNoTokenRequestCacheError();\r\n        }\r\n        var parsedRequest = this.validateAndParseJson(browserCrypto.base64Decode(encodedTokenRequest));\r\n        if (!parsedRequest) {\r\n            throw BrowserAuthError.createUnableToParseTokenRequestCacheError();\r\n        }\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\r\n        // Get cached authority and use if no authority is cached with request.\r\n        if (StringUtils.isEmpty(parsedRequest.authority)) {\r\n            var authorityCacheKey = this.generateAuthorityKey(state);\r\n            var cachedAuthority = this.getTemporaryCache(authorityCacheKey);\r\n            if (!cachedAuthority) {\r\n                throw BrowserAuthError.createNoCachedAuthorityError();\r\n            }\r\n            parsedRequest.authority = cachedAuthority;\r\n        }\r\n        return parsedRequest;\r\n    };\r\n    /**\r\n     * Gets cached native request for redirect flows\r\n     */\r\n    BrowserCacheManager.prototype.getCachedNativeRequest = function () {\r\n        this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest called\");\r\n        var cachedRequest = this.getTemporaryCache(TemporaryCacheKeys.NATIVE_REQUEST, true);\r\n        if (!cachedRequest) {\r\n            this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest: No cached native request found\");\r\n            return null;\r\n        }\r\n        var parsedRequest = this.validateAndParseJson(cachedRequest);\r\n        if (!parsedRequest) {\r\n            this.logger.error(\"BrowserCacheManager.getCachedNativeRequest: Unable to parse native request\");\r\n            return null;\r\n        }\r\n        return parsedRequest;\r\n    };\r\n    BrowserCacheManager.prototype.isInteractionInProgress = function (matchClientId) {\r\n        var clientId = this.getInteractionInProgress();\r\n        if (matchClientId) {\r\n            return clientId === this.clientId;\r\n        }\r\n        else {\r\n            return !!clientId;\r\n        }\r\n    };\r\n    BrowserCacheManager.prototype.getInteractionInProgress = function () {\r\n        var key = Constants.CACHE_PREFIX + \".\" + TemporaryCacheKeys.INTERACTION_STATUS_KEY;\r\n        return this.getTemporaryCache(key, false);\r\n    };\r\n    BrowserCacheManager.prototype.setInteractionInProgress = function (inProgress) {\r\n        // Ensure we don't overwrite interaction in progress for a different clientId\r\n        var key = Constants.CACHE_PREFIX + \".\" + TemporaryCacheKeys.INTERACTION_STATUS_KEY;\r\n        if (inProgress) {\r\n            if (this.getInteractionInProgress()) {\r\n                throw BrowserAuthError.createInteractionInProgressError();\r\n            }\r\n            else {\r\n                // No interaction is in progress\r\n                this.setTemporaryCache(key, this.clientId, false);\r\n            }\r\n        }\r\n        else if (!inProgress && this.getInteractionInProgress() === this.clientId) {\r\n            this.removeItem(key);\r\n        }\r\n    };\r\n    /**\r\n     * Returns username retrieved from ADAL or MSAL v1 idToken\r\n     */\r\n    BrowserCacheManager.prototype.getLegacyLoginHint = function () {\r\n        // Only check for adal/msal token if no SSO params are being used\r\n        var adalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ADAL_ID_TOKEN);\r\n        if (adalIdTokenString) {\r\n            this.browserStorage.removeItem(PersistentCacheKeys.ADAL_ID_TOKEN);\r\n            this.logger.verbose(\"Cached ADAL id token retrieved.\");\r\n        }\r\n        // Check for cached MSAL v1 id token\r\n        var msalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ID_TOKEN, true);\r\n        if (msalIdTokenString) {\r\n            this.removeItem(this.generateCacheKey(PersistentCacheKeys.ID_TOKEN));\r\n            this.logger.verbose(\"Cached MSAL.js v1 id token retrieved\");\r\n        }\r\n        var cachedIdTokenString = msalIdTokenString || adalIdTokenString;\r\n        if (cachedIdTokenString) {\r\n            var cachedIdToken = new IdToken(cachedIdTokenString, this.cryptoImpl);\r\n            if (cachedIdToken.claims && cachedIdToken.claims.preferred_username) {\r\n                this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 preferred_username as loginHint\");\r\n                return cachedIdToken.claims.preferred_username;\r\n            }\r\n            else if (cachedIdToken.claims && cachedIdToken.claims.upn) {\r\n                this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 upn as loginHint\");\r\n                return cachedIdToken.claims.upn;\r\n            }\r\n            else {\r\n                this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, however, no account hint claim found. Enable preferred_username or upn id token claim to get SSO.\");\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Updates a credential's cache key if the current cache key is outdated\r\n     */\r\n    BrowserCacheManager.prototype.updateCredentialCacheKey = function (currentCacheKey, credential) {\r\n        var updatedCacheKey = credential.generateCredentialKey();\r\n        if (currentCacheKey !== updatedCacheKey) {\r\n            var cacheItem = this.getItem(currentCacheKey);\r\n            if (cacheItem) {\r\n                this.removeItem(currentCacheKey);\r\n                this.setItem(updatedCacheKey, cacheItem);\r\n                this.logger.verbose(\"Updated an outdated \" + credential.credentialType + \" cache key\");\r\n                return updatedCacheKey;\r\n            }\r\n            else {\r\n                this.logger.error(\"Attempted to update an outdated \" + credential.credentialType + \" cache key but no item matching the outdated key was found in storage\");\r\n            }\r\n        }\r\n        return currentCacheKey;\r\n    };\r\n    /**\r\n     * Returns application id as redirect context during AcquireTokenRedirect flow.\r\n     */\r\n    BrowserCacheManager.prototype.getRedirectRequestContext = function () {\r\n        return this.getTemporaryCache(TemporaryCacheKeys.REDIRECT_CONTEXT, true);\r\n    };\r\n    /**\r\n     * Sets application id as the redirect context during AcquireTokenRedirect flow.\r\n     * @param value\r\n     */\r\n    BrowserCacheManager.prototype.setRedirectRequestContext = function (value) {\r\n        this.setTemporaryCache(TemporaryCacheKeys.REDIRECT_CONTEXT, value, true);\r\n    };\r\n    return BrowserCacheManager;\r\n}(CacheManager));\r\nvar DEFAULT_BROWSER_CACHE_MANAGER = function (clientId, logger) {\r\n    var cacheOptions = {\r\n        cacheLocation: BrowserCacheLocation.MemoryStorage,\r\n        temporaryCacheLocation: BrowserCacheLocation.MemoryStorage,\r\n        storeAuthStateInCookie: false,\r\n        secureCookies: false,\r\n        cacheMigrationEnabled: false,\r\n        claimsBasedCachingEnabled: true\r\n    };\r\n    return new BrowserCacheManager(clientId, cacheOptions, DEFAULT_CRYPTO_IMPLEMENTATION, logger);\r\n};\n\nexport { BrowserCacheManager, DEFAULT_BROWSER_CACHE_MANAGER };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}