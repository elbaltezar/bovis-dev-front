{"ast":null,"code":"/*! @azure/msal-common v13.3.1 2023-10-27 */\n'use strict';\n\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { buildClientInfo } from '../account/ClientInfo.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { StringUtils } from '../utils/StringUtils.js';\nimport { ServerError } from '../error/ServerError.js';\nimport { AuthToken } from '../account/AuthToken.js';\nimport { ScopeSet } from '../request/ScopeSet.js';\nimport { AccountEntity } from '../cache/entities/AccountEntity.js';\nimport { AuthorityType } from '../authority/AuthorityType.js';\nimport { IdTokenEntity } from '../cache/entities/IdTokenEntity.js';\nimport { AccessTokenEntity } from '../cache/entities/AccessTokenEntity.js';\nimport { RefreshTokenEntity } from '../cache/entities/RefreshTokenEntity.js';\nimport { InteractionRequiredAuthError } from '../error/InteractionRequiredAuthError.js';\nimport { CacheRecord } from '../cache/entities/CacheRecord.js';\nimport { ProtocolUtils } from '../utils/ProtocolUtils.js';\nimport { Constants, AuthenticationScheme, THE_FAMILY_ID } from '../utils/Constants.js';\nimport { PopTokenGenerator } from '../crypto/PopTokenGenerator.js';\nimport { AppMetadataEntity } from '../cache/entities/AppMetadataEntity.js';\nimport { TokenCacheContext } from '../cache/persistence/TokenCacheContext.js';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Class that handles response parsing.\r\n */\n\nvar ResponseHandler =\n/** @class */\nfunction () {\n  function ResponseHandler(clientId, cacheStorage, cryptoObj, logger, serializableCache, persistencePlugin, performanceClient) {\n    this.clientId = clientId;\n    this.cacheStorage = cacheStorage;\n    this.cryptoObj = cryptoObj;\n    this.logger = logger;\n    this.serializableCache = serializableCache;\n    this.persistencePlugin = persistencePlugin;\n    this.performanceClient = performanceClient;\n  }\n  /**\r\n   * Function which validates server authorization code response.\r\n   * @param serverResponseHash\r\n   * @param cachedState\r\n   * @param cryptoObj\r\n   */\n\n\n  ResponseHandler.prototype.validateServerAuthorizationCodeResponse = function (serverResponseHash, cachedState, cryptoObj) {\n    if (!serverResponseHash.state || !cachedState) {\n      throw !serverResponseHash.state ? ClientAuthError.createStateNotFoundError(\"Server State\") : ClientAuthError.createStateNotFoundError(\"Cached State\");\n    }\n\n    if (decodeURIComponent(serverResponseHash.state) !== decodeURIComponent(cachedState)) {\n      throw ClientAuthError.createStateMismatchError();\n    } // Check for error\n\n\n    if (serverResponseHash.error || serverResponseHash.error_description || serverResponseHash.suberror) {\n      if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponseHash.error, serverResponseHash.error_description, serverResponseHash.suberror)) {\n        throw new InteractionRequiredAuthError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror, serverResponseHash.timestamp || Constants.EMPTY_STRING, serverResponseHash.trace_id || Constants.EMPTY_STRING, serverResponseHash.correlation_id || Constants.EMPTY_STRING, serverResponseHash.claims || Constants.EMPTY_STRING);\n      }\n\n      throw new ServerError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);\n    }\n\n    if (serverResponseHash.client_info) {\n      buildClientInfo(serverResponseHash.client_info, cryptoObj);\n    }\n  };\n  /**\r\n   * Function which validates server authorization token response.\r\n   * @param serverResponse\r\n   */\n\n\n  ResponseHandler.prototype.validateTokenResponse = function (serverResponse) {\n    // Check for error\n    if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {\n      if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {\n        throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || Constants.EMPTY_STRING, serverResponse.trace_id || Constants.EMPTY_STRING, serverResponse.correlation_id || Constants.EMPTY_STRING, serverResponse.claims || Constants.EMPTY_STRING);\n      }\n\n      var errString = serverResponse.error_codes + \" - [\" + serverResponse.timestamp + \"]: \" + serverResponse.error_description + \" - Correlation ID: \" + serverResponse.correlation_id + \" - Trace ID: \" + serverResponse.trace_id;\n      throw new ServerError(serverResponse.error, errString, serverResponse.suberror);\n    }\n  };\n  /**\r\n   * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.\r\n   * @param serverTokenResponse\r\n   * @param authority\r\n   */\n\n\n  ResponseHandler.prototype.handleServerTokenResponse = function (serverTokenResponse, authority, reqTimestamp, request, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse, serverRequestId) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var idTokenObj, authTime, requestStateObj, cacheRecord, cacheContext, key, account;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.HandleServerTokenResponse, serverTokenResponse.correlation_id);\n\n            if (serverTokenResponse.id_token) {\n              idTokenObj = new AuthToken(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj); // token nonce check (TODO: Add a warning if no nonce is given?)\n\n              if (authCodePayload && !StringUtils.isEmpty(authCodePayload.nonce)) {\n                if (idTokenObj.claims.nonce !== authCodePayload.nonce) {\n                  throw ClientAuthError.createNonceMismatchError();\n                }\n              } // token max_age check\n\n\n              if (request.maxAge || request.maxAge === 0) {\n                authTime = idTokenObj.claims.auth_time;\n\n                if (!authTime) {\n                  throw ClientAuthError.createAuthTimeNotFoundError();\n                }\n\n                AuthToken.checkMaxAge(authTime, request.maxAge);\n              }\n            } // generate homeAccountId\n\n\n            this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenObj);\n\n            if (!!authCodePayload && !!authCodePayload.state) {\n              requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);\n            } // Add keyId from request to serverTokenResponse if defined\n\n\n            serverTokenResponse.key_id = serverTokenResponse.key_id || request.sshKid || undefined;\n            cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenObj, userAssertionHash, authCodePayload);\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1,, 5, 8]);\n\n            if (!(this.persistencePlugin && this.serializableCache)) return [3\n            /*break*/\n            , 3];\n            this.logger.verbose(\"Persistence enabled, calling beforeCacheAccess\");\n            cacheContext = new TokenCacheContext(this.serializableCache, true);\n            return [4\n            /*yield*/\n            , this.persistencePlugin.beforeCacheAccess(cacheContext)];\n\n          case 2:\n            _b.sent();\n\n            _b.label = 3;\n\n          case 3:\n            /*\r\n             * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.\r\n             * If not present, we should return null, as it's the case that another application called removeAccount in between\r\n             * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal, unless explicitly flagged by\r\n             * the developer, as in the case of refresh token flow used in ADAL Node to MSAL Node migration.\r\n             */\n            if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {\n              key = cacheRecord.account.generateAccountKey();\n              account = this.cacheStorage.getAccount(key);\n\n              if (!account) {\n                this.logger.warning(\"Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache\");\n                return [2\n                /*return*/\n                , ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, undefined, serverRequestId)];\n              }\n            }\n\n            return [4\n            /*yield*/\n            , this.cacheStorage.saveCacheRecord(cacheRecord)];\n\n          case 4:\n            _b.sent();\n\n            return [3\n            /*break*/\n            , 8];\n\n          case 5:\n            if (!(this.persistencePlugin && this.serializableCache && cacheContext)) return [3\n            /*break*/\n            , 7];\n            this.logger.verbose(\"Persistence enabled, calling afterCacheAccess\");\n            return [4\n            /*yield*/\n            , this.persistencePlugin.afterCacheAccess(cacheContext)];\n\n          case 6:\n            _b.sent();\n\n            _b.label = 7;\n\n          case 7:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 8:\n            return [2\n            /*return*/\n            , ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, serverTokenResponse, serverRequestId)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Generates CacheRecord\r\n   * @param serverTokenResponse\r\n   * @param idTokenObj\r\n   * @param authority\r\n   */\n\n\n  ResponseHandler.prototype.generateCacheRecord = function (serverTokenResponse, authority, reqTimestamp, request, idTokenObj, userAssertionHash, authCodePayload) {\n    var env = authority.getPreferredCache();\n\n    if (StringUtils.isEmpty(env)) {\n      throw ClientAuthError.createInvalidCacheEnvironmentError();\n    } // IdToken: non AAD scenarios can have empty realm\n\n\n    var cachedIdToken;\n    var cachedAccount;\n\n    if (!StringUtils.isEmpty(serverTokenResponse.id_token) && !!idTokenObj) {\n      cachedIdToken = IdTokenEntity.createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token || Constants.EMPTY_STRING, this.clientId, idTokenObj.claims.tid || Constants.EMPTY_STRING);\n      cachedAccount = this.generateAccountEntity(serverTokenResponse, idTokenObj, authority, authCodePayload);\n    } // AccessToken\n\n\n    var cachedAccessToken = null;\n\n    if (!StringUtils.isEmpty(serverTokenResponse.access_token)) {\n      // If scopes not returned in server response, use request scopes\n      var responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request.scopes || []);\n      /*\r\n       * Use timestamp calculated before request\r\n       * Server may return timestamps as strings, parse to numbers if so.\r\n       */\n\n      var expiresIn = (typeof serverTokenResponse.expires_in === \"string\" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;\n      var extExpiresIn = (typeof serverTokenResponse.ext_expires_in === \"string\" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;\n      var refreshIn = (typeof serverTokenResponse.refresh_in === \"string\" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || undefined;\n      var tokenExpirationSeconds = reqTimestamp + expiresIn;\n      var extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;\n      var refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : undefined; // non AAD scenarios can have empty realm\n\n      cachedAccessToken = AccessTokenEntity.createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token || Constants.EMPTY_STRING, this.clientId, idTokenObj ? idTokenObj.claims.tid || Constants.EMPTY_STRING : authority.tenant, responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request.claims, request.requestedClaimsHash);\n    } // refreshToken\n\n\n    var cachedRefreshToken = null;\n\n    if (!StringUtils.isEmpty(serverTokenResponse.refresh_token)) {\n      cachedRefreshToken = RefreshTokenEntity.createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token || Constants.EMPTY_STRING, this.clientId, serverTokenResponse.foci, userAssertionHash);\n    } // appMetadata\n\n\n    var cachedAppMetadata = null;\n\n    if (!StringUtils.isEmpty(serverTokenResponse.foci)) {\n      cachedAppMetadata = AppMetadataEntity.createAppMetadataEntity(this.clientId, env, serverTokenResponse.foci);\n    }\n\n    return new CacheRecord(cachedAccount, cachedIdToken, cachedAccessToken, cachedRefreshToken, cachedAppMetadata);\n  };\n  /**\r\n   * Generate Account\r\n   * @param serverTokenResponse\r\n   * @param idToken\r\n   * @param authority\r\n   */\n\n\n  ResponseHandler.prototype.generateAccountEntity = function (serverTokenResponse, idToken, authority, authCodePayload) {\n    var authorityType = authority.authorityType;\n    var cloudGraphHostName = authCodePayload ? authCodePayload.cloud_graph_host_name : Constants.EMPTY_STRING;\n    var msGraphhost = authCodePayload ? authCodePayload.msgraph_host : Constants.EMPTY_STRING; // ADFS does not require client_info in the response\n\n    if (authorityType === AuthorityType.Adfs) {\n      this.logger.verbose(\"Authority type is ADFS, creating ADFS account\");\n      return AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);\n    } // This fallback applies to B2C as well as they fall under an AAD account type.\n\n\n    if (StringUtils.isEmpty(serverTokenResponse.client_info) && authority.protocolMode === \"AAD\") {\n      throw ClientAuthError.createClientInfoEmptyError();\n    }\n\n    return serverTokenResponse.client_info ? AccountEntity.createAccount(serverTokenResponse.client_info, this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost) : AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);\n  };\n  /**\r\n   * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.\r\n   *\r\n   * Optionally takes a state string that is set as-is in the response.\r\n   *\r\n   * @param cacheRecord\r\n   * @param idTokenObj\r\n   * @param fromTokenCache\r\n   * @param stateString\r\n   */\n\n\n  ResponseHandler.generateAuthenticationResult = function (cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenObj, requestState, serverTokenResponse, requestId) {\n    var _a, _b, _c;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var accessToken, responseScopes, expiresOn, extExpiresOn, familyId, popTokenGenerator, _d, secret, keyId, uid, tid;\n\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            accessToken = Constants.EMPTY_STRING;\n            responseScopes = [];\n            expiresOn = null;\n            familyId = Constants.EMPTY_STRING;\n            if (!cacheRecord.accessToken) return [3\n            /*break*/\n            , 4];\n            if (!(cacheRecord.accessToken.tokenType === AuthenticationScheme.POP)) return [3\n            /*break*/\n            , 2];\n            popTokenGenerator = new PopTokenGenerator(cryptoObj);\n            _d = cacheRecord.accessToken, secret = _d.secret, keyId = _d.keyId;\n\n            if (!keyId) {\n              throw ClientAuthError.createKeyIdMissingError();\n            }\n\n            return [4\n            /*yield*/\n            , popTokenGenerator.signPopToken(secret, keyId, request)];\n\n          case 1:\n            accessToken = _e.sent();\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            accessToken = cacheRecord.accessToken.secret;\n            _e.label = 3;\n\n          case 3:\n            responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();\n            expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1000);\n            extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1000);\n            _e.label = 4;\n\n          case 4:\n            if (cacheRecord.appMetadata) {\n              familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : Constants.EMPTY_STRING;\n            }\n\n            uid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.oid) || (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.sub) || Constants.EMPTY_STRING;\n            tid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.tid) || Constants.EMPTY_STRING; // for hybrid + native bridge enablement, send back the native account Id\n\n            if ((serverTokenResponse === null || serverTokenResponse === void 0 ? void 0 : serverTokenResponse.spa_accountid) && !!cacheRecord.account) {\n              cacheRecord.account.nativeAccountId = serverTokenResponse === null || serverTokenResponse === void 0 ? void 0 : serverTokenResponse.spa_accountid;\n            }\n\n            return [2\n            /*return*/\n            , {\n              authority: authority.canonicalAuthority,\n              uniqueId: uid,\n              tenantId: tid,\n              scopes: responseScopes,\n              account: cacheRecord.account ? cacheRecord.account.getAccountInfo() : null,\n              idToken: idTokenObj ? idTokenObj.rawToken : Constants.EMPTY_STRING,\n              idTokenClaims: idTokenObj ? idTokenObj.claims : {},\n              accessToken: accessToken,\n              fromCache: fromTokenCache,\n              expiresOn: expiresOn,\n              correlationId: request.correlationId,\n              requestId: requestId || Constants.EMPTY_STRING,\n              extExpiresOn: extExpiresOn,\n              familyId: familyId,\n              tokenType: ((_a = cacheRecord.accessToken) === null || _a === void 0 ? void 0 : _a.tokenType) || Constants.EMPTY_STRING,\n              state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,\n              cloudGraphHostName: ((_b = cacheRecord.account) === null || _b === void 0 ? void 0 : _b.cloudGraphHostName) || Constants.EMPTY_STRING,\n              msGraphHost: ((_c = cacheRecord.account) === null || _c === void 0 ? void 0 : _c.msGraphHost) || Constants.EMPTY_STRING,\n              code: serverTokenResponse === null || serverTokenResponse === void 0 ? void 0 : serverTokenResponse.spa_code,\n              fromNativeBroker: false\n            }];\n        }\n      });\n    });\n  };\n\n  return ResponseHandler;\n}();\n\nexport { ResponseHandler };","map":{"version":3,"names":["__awaiter","__generator","buildClientInfo","ClientAuthError","StringUtils","ServerError","AuthToken","ScopeSet","AccountEntity","AuthorityType","IdTokenEntity","AccessTokenEntity","RefreshTokenEntity","InteractionRequiredAuthError","CacheRecord","ProtocolUtils","Constants","AuthenticationScheme","THE_FAMILY_ID","PopTokenGenerator","AppMetadataEntity","TokenCacheContext","PerformanceEvents","ResponseHandler","clientId","cacheStorage","cryptoObj","logger","serializableCache","persistencePlugin","performanceClient","prototype","validateServerAuthorizationCodeResponse","serverResponseHash","cachedState","state","createStateNotFoundError","decodeURIComponent","createStateMismatchError","error","error_description","suberror","isInteractionRequiredError","EMPTY_STRING","timestamp","trace_id","correlation_id","claims","client_info","validateTokenResponse","serverResponse","errString","error_codes","handleServerTokenResponse","serverTokenResponse","authority","reqTimestamp","request","authCodePayload","userAssertionHash","handlingRefreshTokenResponse","forceCacheRefreshTokenResponse","serverRequestId","_a","idTokenObj","authTime","requestStateObj","cacheRecord","cacheContext","key","account","_b","label","addQueueMeasurement","HandleServerTokenResponse","id_token","isEmpty","nonce","createNonceMismatchError","maxAge","auth_time","createAuthTimeNotFoundError","checkMaxAge","homeAccountIdentifier","generateHomeAccountId","authorityType","parseRequestState","key_id","sshKid","undefined","generateCacheRecord","trys","push","verbose","beforeCacheAccess","sent","generateAccountKey","getAccount","warning","generateAuthenticationResult","saveCacheRecord","afterCacheAccess","env","getPreferredCache","createInvalidCacheEnvironmentError","cachedIdToken","cachedAccount","createIdTokenEntity","tid","generateAccountEntity","cachedAccessToken","access_token","responseScopes","scope","fromString","scopes","expiresIn","expires_in","parseInt","extExpiresIn","ext_expires_in","refreshIn","refresh_in","tokenExpirationSeconds","extendedTokenExpirationSeconds","refreshOnSeconds","createAccessTokenEntity","tenant","printScopes","token_type","requestedClaimsHash","cachedRefreshToken","refresh_token","createRefreshTokenEntity","foci","cachedAppMetadata","createAppMetadataEntity","idToken","cloudGraphHostName","cloud_graph_host_name","msGraphhost","msgraph_host","Adfs","createGenericAccount","protocolMode","createClientInfoEmptyError","createAccount","fromTokenCache","requestState","requestId","_c","accessToken","expiresOn","extExpiresOn","familyId","popTokenGenerator","_d","secret","keyId","uid","_e","tokenType","POP","createKeyIdMissingError","signPopToken","target","asArray","Date","Number","extendedExpiresOn","appMetadata","oid","sub","spa_accountid","nativeAccountId","canonicalAuthority","uniqueId","tenantId","getAccountInfo","rawToken","idTokenClaims","fromCache","correlationId","userRequestState","msGraphHost","code","spa_code","fromNativeBroker"],"sources":["F:/Bovis/Front/bovis-dev/node_modules/@azure/msal-common/dist/response/ResponseHandler.js"],"sourcesContent":["/*! @azure/msal-common v13.3.1 2023-10-27 */\n'use strict';\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { buildClientInfo } from '../account/ClientInfo.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { StringUtils } from '../utils/StringUtils.js';\nimport { ServerError } from '../error/ServerError.js';\nimport { AuthToken } from '../account/AuthToken.js';\nimport { ScopeSet } from '../request/ScopeSet.js';\nimport { AccountEntity } from '../cache/entities/AccountEntity.js';\nimport { AuthorityType } from '../authority/AuthorityType.js';\nimport { IdTokenEntity } from '../cache/entities/IdTokenEntity.js';\nimport { AccessTokenEntity } from '../cache/entities/AccessTokenEntity.js';\nimport { RefreshTokenEntity } from '../cache/entities/RefreshTokenEntity.js';\nimport { InteractionRequiredAuthError } from '../error/InteractionRequiredAuthError.js';\nimport { CacheRecord } from '../cache/entities/CacheRecord.js';\nimport { ProtocolUtils } from '../utils/ProtocolUtils.js';\nimport { Constants, AuthenticationScheme, THE_FAMILY_ID } from '../utils/Constants.js';\nimport { PopTokenGenerator } from '../crypto/PopTokenGenerator.js';\nimport { AppMetadataEntity } from '../cache/entities/AppMetadataEntity.js';\nimport { TokenCacheContext } from '../cache/persistence/TokenCacheContext.js';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Class that handles response parsing.\r\n */\r\nvar ResponseHandler = /** @class */ (function () {\r\n    function ResponseHandler(clientId, cacheStorage, cryptoObj, logger, serializableCache, persistencePlugin, performanceClient) {\r\n        this.clientId = clientId;\r\n        this.cacheStorage = cacheStorage;\r\n        this.cryptoObj = cryptoObj;\r\n        this.logger = logger;\r\n        this.serializableCache = serializableCache;\r\n        this.persistencePlugin = persistencePlugin;\r\n        this.performanceClient = performanceClient;\r\n    }\r\n    /**\r\n     * Function which validates server authorization code response.\r\n     * @param serverResponseHash\r\n     * @param cachedState\r\n     * @param cryptoObj\r\n     */\r\n    ResponseHandler.prototype.validateServerAuthorizationCodeResponse = function (serverResponseHash, cachedState, cryptoObj) {\r\n        if (!serverResponseHash.state || !cachedState) {\r\n            throw !serverResponseHash.state ? ClientAuthError.createStateNotFoundError(\"Server State\") : ClientAuthError.createStateNotFoundError(\"Cached State\");\r\n        }\r\n        if (decodeURIComponent(serverResponseHash.state) !== decodeURIComponent(cachedState)) {\r\n            throw ClientAuthError.createStateMismatchError();\r\n        }\r\n        // Check for error\r\n        if (serverResponseHash.error || serverResponseHash.error_description || serverResponseHash.suberror) {\r\n            if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponseHash.error, serverResponseHash.error_description, serverResponseHash.suberror)) {\r\n                throw new InteractionRequiredAuthError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror, serverResponseHash.timestamp || Constants.EMPTY_STRING, serverResponseHash.trace_id || Constants.EMPTY_STRING, serverResponseHash.correlation_id || Constants.EMPTY_STRING, serverResponseHash.claims || Constants.EMPTY_STRING);\r\n            }\r\n            throw new ServerError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);\r\n        }\r\n        if (serverResponseHash.client_info) {\r\n            buildClientInfo(serverResponseHash.client_info, cryptoObj);\r\n        }\r\n    };\r\n    /**\r\n     * Function which validates server authorization token response.\r\n     * @param serverResponse\r\n     */\r\n    ResponseHandler.prototype.validateTokenResponse = function (serverResponse) {\r\n        // Check for error\r\n        if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {\r\n            if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {\r\n                throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || Constants.EMPTY_STRING, serverResponse.trace_id || Constants.EMPTY_STRING, serverResponse.correlation_id || Constants.EMPTY_STRING, serverResponse.claims || Constants.EMPTY_STRING);\r\n            }\r\n            var errString = serverResponse.error_codes + \" - [\" + serverResponse.timestamp + \"]: \" + serverResponse.error_description + \" - Correlation ID: \" + serverResponse.correlation_id + \" - Trace ID: \" + serverResponse.trace_id;\r\n            throw new ServerError(serverResponse.error, errString, serverResponse.suberror);\r\n        }\r\n    };\r\n    /**\r\n     * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.\r\n     * @param serverTokenResponse\r\n     * @param authority\r\n     */\r\n    ResponseHandler.prototype.handleServerTokenResponse = function (serverTokenResponse, authority, reqTimestamp, request, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse, serverRequestId) {\r\n        var _a;\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var idTokenObj, authTime, requestStateObj, cacheRecord, cacheContext, key, account;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.HandleServerTokenResponse, serverTokenResponse.correlation_id);\r\n                        if (serverTokenResponse.id_token) {\r\n                            idTokenObj = new AuthToken(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj);\r\n                            // token nonce check (TODO: Add a warning if no nonce is given?)\r\n                            if (authCodePayload && !StringUtils.isEmpty(authCodePayload.nonce)) {\r\n                                if (idTokenObj.claims.nonce !== authCodePayload.nonce) {\r\n                                    throw ClientAuthError.createNonceMismatchError();\r\n                                }\r\n                            }\r\n                            // token max_age check\r\n                            if (request.maxAge || (request.maxAge === 0)) {\r\n                                authTime = idTokenObj.claims.auth_time;\r\n                                if (!authTime) {\r\n                                    throw ClientAuthError.createAuthTimeNotFoundError();\r\n                                }\r\n                                AuthToken.checkMaxAge(authTime, request.maxAge);\r\n                            }\r\n                        }\r\n                        // generate homeAccountId\r\n                        this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenObj);\r\n                        if (!!authCodePayload && !!authCodePayload.state) {\r\n                            requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);\r\n                        }\r\n                        // Add keyId from request to serverTokenResponse if defined\r\n                        serverTokenResponse.key_id = serverTokenResponse.key_id || request.sshKid || undefined;\r\n                        cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenObj, userAssertionHash, authCodePayload);\r\n                        _b.label = 1;\r\n                    case 1:\r\n                        _b.trys.push([1, , 5, 8]);\r\n                        if (!(this.persistencePlugin && this.serializableCache)) return [3 /*break*/, 3];\r\n                        this.logger.verbose(\"Persistence enabled, calling beforeCacheAccess\");\r\n                        cacheContext = new TokenCacheContext(this.serializableCache, true);\r\n                        return [4 /*yield*/, this.persistencePlugin.beforeCacheAccess(cacheContext)];\r\n                    case 2:\r\n                        _b.sent();\r\n                        _b.label = 3;\r\n                    case 3:\r\n                        /*\r\n                         * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.\r\n                         * If not present, we should return null, as it's the case that another application called removeAccount in between\r\n                         * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal, unless explicitly flagged by\r\n                         * the developer, as in the case of refresh token flow used in ADAL Node to MSAL Node migration.\r\n                         */\r\n                        if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {\r\n                            key = cacheRecord.account.generateAccountKey();\r\n                            account = this.cacheStorage.getAccount(key);\r\n                            if (!account) {\r\n                                this.logger.warning(\"Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache\");\r\n                                return [2 /*return*/, ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, undefined, serverRequestId)];\r\n                            }\r\n                        }\r\n                        return [4 /*yield*/, this.cacheStorage.saveCacheRecord(cacheRecord)];\r\n                    case 4:\r\n                        _b.sent();\r\n                        return [3 /*break*/, 8];\r\n                    case 5:\r\n                        if (!(this.persistencePlugin && this.serializableCache && cacheContext)) return [3 /*break*/, 7];\r\n                        this.logger.verbose(\"Persistence enabled, calling afterCacheAccess\");\r\n                        return [4 /*yield*/, this.persistencePlugin.afterCacheAccess(cacheContext)];\r\n                    case 6:\r\n                        _b.sent();\r\n                        _b.label = 7;\r\n                    case 7: return [7 /*endfinally*/];\r\n                    case 8: return [2 /*return*/, ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, serverTokenResponse, serverRequestId)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Generates CacheRecord\r\n     * @param serverTokenResponse\r\n     * @param idTokenObj\r\n     * @param authority\r\n     */\r\n    ResponseHandler.prototype.generateCacheRecord = function (serverTokenResponse, authority, reqTimestamp, request, idTokenObj, userAssertionHash, authCodePayload) {\r\n        var env = authority.getPreferredCache();\r\n        if (StringUtils.isEmpty(env)) {\r\n            throw ClientAuthError.createInvalidCacheEnvironmentError();\r\n        }\r\n        // IdToken: non AAD scenarios can have empty realm\r\n        var cachedIdToken;\r\n        var cachedAccount;\r\n        if (!StringUtils.isEmpty(serverTokenResponse.id_token) && !!idTokenObj) {\r\n            cachedIdToken = IdTokenEntity.createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token || Constants.EMPTY_STRING, this.clientId, idTokenObj.claims.tid || Constants.EMPTY_STRING);\r\n            cachedAccount = this.generateAccountEntity(serverTokenResponse, idTokenObj, authority, authCodePayload);\r\n        }\r\n        // AccessToken\r\n        var cachedAccessToken = null;\r\n        if (!StringUtils.isEmpty(serverTokenResponse.access_token)) {\r\n            // If scopes not returned in server response, use request scopes\r\n            var responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request.scopes || []);\r\n            /*\r\n             * Use timestamp calculated before request\r\n             * Server may return timestamps as strings, parse to numbers if so.\r\n             */\r\n            var expiresIn = (typeof serverTokenResponse.expires_in === \"string\" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;\r\n            var extExpiresIn = (typeof serverTokenResponse.ext_expires_in === \"string\" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;\r\n            var refreshIn = (typeof serverTokenResponse.refresh_in === \"string\" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || undefined;\r\n            var tokenExpirationSeconds = reqTimestamp + expiresIn;\r\n            var extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;\r\n            var refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : undefined;\r\n            // non AAD scenarios can have empty realm\r\n            cachedAccessToken = AccessTokenEntity.createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token || Constants.EMPTY_STRING, this.clientId, idTokenObj ? idTokenObj.claims.tid || Constants.EMPTY_STRING : authority.tenant, responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request.claims, request.requestedClaimsHash);\r\n        }\r\n        // refreshToken\r\n        var cachedRefreshToken = null;\r\n        if (!StringUtils.isEmpty(serverTokenResponse.refresh_token)) {\r\n            cachedRefreshToken = RefreshTokenEntity.createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token || Constants.EMPTY_STRING, this.clientId, serverTokenResponse.foci, userAssertionHash);\r\n        }\r\n        // appMetadata\r\n        var cachedAppMetadata = null;\r\n        if (!StringUtils.isEmpty(serverTokenResponse.foci)) {\r\n            cachedAppMetadata = AppMetadataEntity.createAppMetadataEntity(this.clientId, env, serverTokenResponse.foci);\r\n        }\r\n        return new CacheRecord(cachedAccount, cachedIdToken, cachedAccessToken, cachedRefreshToken, cachedAppMetadata);\r\n    };\r\n    /**\r\n     * Generate Account\r\n     * @param serverTokenResponse\r\n     * @param idToken\r\n     * @param authority\r\n     */\r\n    ResponseHandler.prototype.generateAccountEntity = function (serverTokenResponse, idToken, authority, authCodePayload) {\r\n        var authorityType = authority.authorityType;\r\n        var cloudGraphHostName = authCodePayload ? authCodePayload.cloud_graph_host_name : Constants.EMPTY_STRING;\r\n        var msGraphhost = authCodePayload ? authCodePayload.msgraph_host : Constants.EMPTY_STRING;\r\n        // ADFS does not require client_info in the response\r\n        if (authorityType === AuthorityType.Adfs) {\r\n            this.logger.verbose(\"Authority type is ADFS, creating ADFS account\");\r\n            return AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);\r\n        }\r\n        // This fallback applies to B2C as well as they fall under an AAD account type.\r\n        if (StringUtils.isEmpty(serverTokenResponse.client_info) && authority.protocolMode === \"AAD\") {\r\n            throw ClientAuthError.createClientInfoEmptyError();\r\n        }\r\n        return serverTokenResponse.client_info ?\r\n            AccountEntity.createAccount(serverTokenResponse.client_info, this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost) :\r\n            AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);\r\n    };\r\n    /**\r\n     * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.\r\n     *\r\n     * Optionally takes a state string that is set as-is in the response.\r\n     *\r\n     * @param cacheRecord\r\n     * @param idTokenObj\r\n     * @param fromTokenCache\r\n     * @param stateString\r\n     */\r\n    ResponseHandler.generateAuthenticationResult = function (cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenObj, requestState, serverTokenResponse, requestId) {\r\n        var _a, _b, _c;\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var accessToken, responseScopes, expiresOn, extExpiresOn, familyId, popTokenGenerator, _d, secret, keyId, uid, tid;\r\n            return __generator(this, function (_e) {\r\n                switch (_e.label) {\r\n                    case 0:\r\n                        accessToken = Constants.EMPTY_STRING;\r\n                        responseScopes = [];\r\n                        expiresOn = null;\r\n                        familyId = Constants.EMPTY_STRING;\r\n                        if (!cacheRecord.accessToken) return [3 /*break*/, 4];\r\n                        if (!(cacheRecord.accessToken.tokenType === AuthenticationScheme.POP)) return [3 /*break*/, 2];\r\n                        popTokenGenerator = new PopTokenGenerator(cryptoObj);\r\n                        _d = cacheRecord.accessToken, secret = _d.secret, keyId = _d.keyId;\r\n                        if (!keyId) {\r\n                            throw ClientAuthError.createKeyIdMissingError();\r\n                        }\r\n                        return [4 /*yield*/, popTokenGenerator.signPopToken(secret, keyId, request)];\r\n                    case 1:\r\n                        accessToken = _e.sent();\r\n                        return [3 /*break*/, 3];\r\n                    case 2:\r\n                        accessToken = cacheRecord.accessToken.secret;\r\n                        _e.label = 3;\r\n                    case 3:\r\n                        responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();\r\n                        expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1000);\r\n                        extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1000);\r\n                        _e.label = 4;\r\n                    case 4:\r\n                        if (cacheRecord.appMetadata) {\r\n                            familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : Constants.EMPTY_STRING;\r\n                        }\r\n                        uid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.oid) || (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.sub) || Constants.EMPTY_STRING;\r\n                        tid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.tid) || Constants.EMPTY_STRING;\r\n                        // for hybrid + native bridge enablement, send back the native account Id\r\n                        if ((serverTokenResponse === null || serverTokenResponse === void 0 ? void 0 : serverTokenResponse.spa_accountid) && !!cacheRecord.account) {\r\n                            cacheRecord.account.nativeAccountId = serverTokenResponse === null || serverTokenResponse === void 0 ? void 0 : serverTokenResponse.spa_accountid;\r\n                        }\r\n                        return [2 /*return*/, {\r\n                                authority: authority.canonicalAuthority,\r\n                                uniqueId: uid,\r\n                                tenantId: tid,\r\n                                scopes: responseScopes,\r\n                                account: cacheRecord.account ? cacheRecord.account.getAccountInfo() : null,\r\n                                idToken: idTokenObj ? idTokenObj.rawToken : Constants.EMPTY_STRING,\r\n                                idTokenClaims: idTokenObj ? idTokenObj.claims : {},\r\n                                accessToken: accessToken,\r\n                                fromCache: fromTokenCache,\r\n                                expiresOn: expiresOn,\r\n                                correlationId: request.correlationId,\r\n                                requestId: requestId || Constants.EMPTY_STRING,\r\n                                extExpiresOn: extExpiresOn,\r\n                                familyId: familyId,\r\n                                tokenType: ((_a = cacheRecord.accessToken) === null || _a === void 0 ? void 0 : _a.tokenType) || Constants.EMPTY_STRING,\r\n                                state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,\r\n                                cloudGraphHostName: ((_b = cacheRecord.account) === null || _b === void 0 ? void 0 : _b.cloudGraphHostName) || Constants.EMPTY_STRING,\r\n                                msGraphHost: ((_c = cacheRecord.account) === null || _c === void 0 ? void 0 : _c.msGraphHost) || Constants.EMPTY_STRING,\r\n                                code: serverTokenResponse === null || serverTokenResponse === void 0 ? void 0 : serverTokenResponse.spa_code,\r\n                                fromNativeBroker: false,\r\n                            }];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return ResponseHandler;\r\n}());\n\nexport { ResponseHandler };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}