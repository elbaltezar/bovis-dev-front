{"ast":null,"code":"/*! @azure/msal-common v13.3.1 2023-10-27 */\n'use strict';\n\nimport { __extends } from '../../_virtual/_tslib.js';\nimport { CredentialEntity } from './CredentialEntity.js';\nimport { CredentialType, AuthenticationScheme } from '../../utils/Constants.js';\nimport { TimeUtils } from '../../utils/TimeUtils.js';\nimport { StringUtils } from '../../utils/StringUtils.js';\nimport { AuthToken } from '../../account/AuthToken.js';\nimport { ClientAuthError } from '../../error/ClientAuthError.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * ACCESS_TOKEN Credential Type\r\n *\r\n * Key:Value Schema:\r\n *\r\n * Key Example: uid.utid-login.microsoftonline.com-accesstoken-clientId-contoso.com-user.read\r\n *\r\n * Value Schema:\r\n * {\r\n *      homeAccountId: home account identifier for the auth scheme,\r\n *      environment: entity that issued the token, represented as a full host\r\n *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other\r\n *      clientId: client ID of the application\r\n *      secret: Actual credential as a string\r\n *      familyId: Family ID identifier, usually only used for refresh tokens\r\n *      realm: Full tenant or organizational identifier that the account belongs to\r\n *      target: Permissions that are included in the token, or for refresh tokens, the resource identifier.\r\n *      cachedAt: Absolute device time when entry was created in the cache.\r\n *      expiresOn: Token expiry time, calculated based on current UTC time in seconds. Represented as a string.\r\n *      extendedExpiresOn: Additional extended expiry time until when token is valid in case of server-side outage. Represented as string in UTC seconds.\r\n *      keyId: used for POP and SSH tokenTypes\r\n *      tokenType: Type of the token issued. Usually \"Bearer\"\r\n * }\r\n */\n\nvar AccessTokenEntity =\n/** @class */\nfunction (_super) {\n  __extends(AccessTokenEntity, _super);\n\n  function AccessTokenEntity() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\r\n   * Create AccessTokenEntity\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param accessToken\r\n   * @param clientId\r\n   * @param tenantId\r\n   * @param scopes\r\n   * @param expiresOn\r\n   * @param extExpiresOn\r\n   */\n\n\n  AccessTokenEntity.createAccessTokenEntity = function (homeAccountId, environment, accessToken, clientId, tenantId, scopes, expiresOn, extExpiresOn, cryptoUtils, refreshOn, tokenType, userAssertionHash, keyId, requestedClaims, requestedClaimsHash) {\n    var _a, _b;\n\n    var atEntity = new AccessTokenEntity();\n    atEntity.homeAccountId = homeAccountId;\n    atEntity.credentialType = CredentialType.ACCESS_TOKEN;\n    atEntity.secret = accessToken;\n    var currentTime = TimeUtils.nowSeconds();\n    atEntity.cachedAt = currentTime.toString();\n    /*\r\n     * Token expiry time.\r\n     * This value should be  calculated based on the current UTC time measured locally and the value  expires_in Represented as a string in JSON.\r\n     */\n\n    atEntity.expiresOn = expiresOn.toString();\n    atEntity.extendedExpiresOn = extExpiresOn.toString();\n\n    if (refreshOn) {\n      atEntity.refreshOn = refreshOn.toString();\n    }\n\n    atEntity.environment = environment;\n    atEntity.clientId = clientId;\n    atEntity.realm = tenantId;\n    atEntity.target = scopes;\n    atEntity.userAssertionHash = userAssertionHash;\n    atEntity.tokenType = StringUtils.isEmpty(tokenType) ? AuthenticationScheme.BEARER : tokenType;\n\n    if (requestedClaims) {\n      atEntity.requestedClaims = requestedClaims;\n      atEntity.requestedClaimsHash = requestedClaimsHash;\n    }\n    /*\r\n     * Create Access Token With Auth Scheme instead of regular access token\r\n     * Cast to lower to handle \"bearer\" from ADFS\r\n     */\n\n\n    if (((_a = atEntity.tokenType) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== AuthenticationScheme.BEARER.toLowerCase()) {\n      atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n\n      switch (atEntity.tokenType) {\n        case AuthenticationScheme.POP:\n          // Make sure keyId is present and add it to credential\n          var tokenClaims = AuthToken.extractTokenClaims(accessToken, cryptoUtils);\n\n          if (!((_b = tokenClaims === null || tokenClaims === void 0 ? void 0 : tokenClaims.cnf) === null || _b === void 0 ? void 0 : _b.kid)) {\n            throw ClientAuthError.createTokenClaimsRequiredError();\n          }\n\n          atEntity.keyId = tokenClaims.cnf.kid;\n          break;\n\n        case AuthenticationScheme.SSH:\n          atEntity.keyId = keyId;\n      }\n    }\n\n    return atEntity;\n  };\n  /**\r\n   * Validates an entity: checks for all expected params\r\n   * @param entity\r\n   */\n\n\n  AccessTokenEntity.isAccessTokenEntity = function (entity) {\n    if (!entity) {\n      return false;\n    }\n\n    return entity.hasOwnProperty(\"homeAccountId\") && entity.hasOwnProperty(\"environment\") && entity.hasOwnProperty(\"credentialType\") && entity.hasOwnProperty(\"realm\") && entity.hasOwnProperty(\"clientId\") && entity.hasOwnProperty(\"secret\") && entity.hasOwnProperty(\"target\") && (entity[\"credentialType\"] === CredentialType.ACCESS_TOKEN || entity[\"credentialType\"] === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);\n  };\n\n  return AccessTokenEntity;\n}(CredentialEntity);\n\nexport { AccessTokenEntity };","map":{"version":3,"names":["__extends","CredentialEntity","CredentialType","AuthenticationScheme","TimeUtils","StringUtils","AuthToken","ClientAuthError","AccessTokenEntity","_super","apply","arguments","createAccessTokenEntity","homeAccountId","environment","accessToken","clientId","tenantId","scopes","expiresOn","extExpiresOn","cryptoUtils","refreshOn","tokenType","userAssertionHash","keyId","requestedClaims","requestedClaimsHash","_a","_b","atEntity","credentialType","ACCESS_TOKEN","secret","currentTime","nowSeconds","cachedAt","toString","extendedExpiresOn","realm","target","isEmpty","BEARER","toLowerCase","ACCESS_TOKEN_WITH_AUTH_SCHEME","POP","tokenClaims","extractTokenClaims","cnf","kid","createTokenClaimsRequiredError","SSH","isAccessTokenEntity","entity","hasOwnProperty"],"sources":["F:/Bovis/Front/bovis-dev/node_modules/@azure/msal-common/dist/cache/entities/AccessTokenEntity.js"],"sourcesContent":["/*! @azure/msal-common v13.3.1 2023-10-27 */\n'use strict';\nimport { __extends } from '../../_virtual/_tslib.js';\nimport { CredentialEntity } from './CredentialEntity.js';\nimport { CredentialType, AuthenticationScheme } from '../../utils/Constants.js';\nimport { TimeUtils } from '../../utils/TimeUtils.js';\nimport { StringUtils } from '../../utils/StringUtils.js';\nimport { AuthToken } from '../../account/AuthToken.js';\nimport { ClientAuthError } from '../../error/ClientAuthError.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * ACCESS_TOKEN Credential Type\r\n *\r\n * Key:Value Schema:\r\n *\r\n * Key Example: uid.utid-login.microsoftonline.com-accesstoken-clientId-contoso.com-user.read\r\n *\r\n * Value Schema:\r\n * {\r\n *      homeAccountId: home account identifier for the auth scheme,\r\n *      environment: entity that issued the token, represented as a full host\r\n *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other\r\n *      clientId: client ID of the application\r\n *      secret: Actual credential as a string\r\n *      familyId: Family ID identifier, usually only used for refresh tokens\r\n *      realm: Full tenant or organizational identifier that the account belongs to\r\n *      target: Permissions that are included in the token, or for refresh tokens, the resource identifier.\r\n *      cachedAt: Absolute device time when entry was created in the cache.\r\n *      expiresOn: Token expiry time, calculated based on current UTC time in seconds. Represented as a string.\r\n *      extendedExpiresOn: Additional extended expiry time until when token is valid in case of server-side outage. Represented as string in UTC seconds.\r\n *      keyId: used for POP and SSH tokenTypes\r\n *      tokenType: Type of the token issued. Usually \"Bearer\"\r\n * }\r\n */\r\nvar AccessTokenEntity = /** @class */ (function (_super) {\r\n    __extends(AccessTokenEntity, _super);\r\n    function AccessTokenEntity() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Create AccessTokenEntity\r\n     * @param homeAccountId\r\n     * @param environment\r\n     * @param accessToken\r\n     * @param clientId\r\n     * @param tenantId\r\n     * @param scopes\r\n     * @param expiresOn\r\n     * @param extExpiresOn\r\n     */\r\n    AccessTokenEntity.createAccessTokenEntity = function (homeAccountId, environment, accessToken, clientId, tenantId, scopes, expiresOn, extExpiresOn, cryptoUtils, refreshOn, tokenType, userAssertionHash, keyId, requestedClaims, requestedClaimsHash) {\r\n        var _a, _b;\r\n        var atEntity = new AccessTokenEntity();\r\n        atEntity.homeAccountId = homeAccountId;\r\n        atEntity.credentialType = CredentialType.ACCESS_TOKEN;\r\n        atEntity.secret = accessToken;\r\n        var currentTime = TimeUtils.nowSeconds();\r\n        atEntity.cachedAt = currentTime.toString();\r\n        /*\r\n         * Token expiry time.\r\n         * This value should be  calculated based on the current UTC time measured locally and the value  expires_in Represented as a string in JSON.\r\n         */\r\n        atEntity.expiresOn = expiresOn.toString();\r\n        atEntity.extendedExpiresOn = extExpiresOn.toString();\r\n        if (refreshOn) {\r\n            atEntity.refreshOn = refreshOn.toString();\r\n        }\r\n        atEntity.environment = environment;\r\n        atEntity.clientId = clientId;\r\n        atEntity.realm = tenantId;\r\n        atEntity.target = scopes;\r\n        atEntity.userAssertionHash = userAssertionHash;\r\n        atEntity.tokenType = StringUtils.isEmpty(tokenType) ? AuthenticationScheme.BEARER : tokenType;\r\n        if (requestedClaims) {\r\n            atEntity.requestedClaims = requestedClaims;\r\n            atEntity.requestedClaimsHash = requestedClaimsHash;\r\n        }\r\n        /*\r\n         * Create Access Token With Auth Scheme instead of regular access token\r\n         * Cast to lower to handle \"bearer\" from ADFS\r\n         */\r\n        if (((_a = atEntity.tokenType) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== AuthenticationScheme.BEARER.toLowerCase()) {\r\n            atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\r\n            switch (atEntity.tokenType) {\r\n                case AuthenticationScheme.POP:\r\n                    // Make sure keyId is present and add it to credential\r\n                    var tokenClaims = AuthToken.extractTokenClaims(accessToken, cryptoUtils);\r\n                    if (!((_b = tokenClaims === null || tokenClaims === void 0 ? void 0 : tokenClaims.cnf) === null || _b === void 0 ? void 0 : _b.kid)) {\r\n                        throw ClientAuthError.createTokenClaimsRequiredError();\r\n                    }\r\n                    atEntity.keyId = tokenClaims.cnf.kid;\r\n                    break;\r\n                case AuthenticationScheme.SSH:\r\n                    atEntity.keyId = keyId;\r\n            }\r\n        }\r\n        return atEntity;\r\n    };\r\n    /**\r\n     * Validates an entity: checks for all expected params\r\n     * @param entity\r\n     */\r\n    AccessTokenEntity.isAccessTokenEntity = function (entity) {\r\n        if (!entity) {\r\n            return false;\r\n        }\r\n        return (entity.hasOwnProperty(\"homeAccountId\") &&\r\n            entity.hasOwnProperty(\"environment\") &&\r\n            entity.hasOwnProperty(\"credentialType\") &&\r\n            entity.hasOwnProperty(\"realm\") &&\r\n            entity.hasOwnProperty(\"clientId\") &&\r\n            entity.hasOwnProperty(\"secret\") &&\r\n            entity.hasOwnProperty(\"target\") &&\r\n            (entity[\"credentialType\"] === CredentialType.ACCESS_TOKEN || entity[\"credentialType\"] === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME));\r\n    };\r\n    return AccessTokenEntity;\r\n}(CredentialEntity));\n\nexport { AccessTokenEntity };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}